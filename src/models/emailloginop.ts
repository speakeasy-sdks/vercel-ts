/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { HTTPMetadata, HTTPMetadata$ } from "./httpmetadata";
import * as z from "zod";

export type EmailLoginRequestBody = {
    /**
     * The user email.
     */
    email: string;
    /**
     * The desired name for the token. It will be displayed on the user account details.
     */
    tokenName?: string | undefined;
};

export type EmailLoginResponseBody2 = {
    /**
     * The token used to verify the user accepted the login request
     */
    token: string;
    /**
     * The code the user is going to receive on the email. **Must** be displayed to the user so they can verify the request is the correct.
     */
    securityCode: string;
};

export type EmailLoginResponseBody1 = {
    token: string;
    securityCode: string;
};

/**
 * The request was successful and an email was sent
 */
export type EmailLoginResponseBody = EmailLoginResponseBody1 | EmailLoginResponseBody2;

export type EmailLoginResponse = {
    httpMeta: HTTPMetadata;
    /**
     * The request was successful and an email was sent
     */
    oneOf?: EmailLoginResponseBody1 | EmailLoginResponseBody2 | undefined;
};

/** @internal */
export namespace EmailLoginRequestBody$ {
    export const inboundSchema: z.ZodType<EmailLoginRequestBody, z.ZodTypeDef, unknown> = z
        .object({
            email: z.string(),
            tokenName: z.string().optional(),
        })
        .transform((v) => {
            return {
                email: v.email,
                ...(v.tokenName === undefined ? null : { tokenName: v.tokenName }),
            };
        });

    export type Outbound = {
        email: string;
        tokenName?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, EmailLoginRequestBody> = z
        .object({
            email: z.string(),
            tokenName: z.string().optional(),
        })
        .transform((v) => {
            return {
                email: v.email,
                ...(v.tokenName === undefined ? null : { tokenName: v.tokenName }),
            };
        });
}

/** @internal */
export namespace EmailLoginResponseBody2$ {
    export const inboundSchema: z.ZodType<EmailLoginResponseBody2, z.ZodTypeDef, unknown> = z
        .object({
            token: z.string(),
            securityCode: z.string(),
        })
        .transform((v) => {
            return {
                token: v.token,
                securityCode: v.securityCode,
            };
        });

    export type Outbound = {
        token: string;
        securityCode: string;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, EmailLoginResponseBody2> = z
        .object({
            token: z.string(),
            securityCode: z.string(),
        })
        .transform((v) => {
            return {
                token: v.token,
                securityCode: v.securityCode,
            };
        });
}

/** @internal */
export namespace EmailLoginResponseBody1$ {
    export const inboundSchema: z.ZodType<EmailLoginResponseBody1, z.ZodTypeDef, unknown> = z
        .object({
            token: z.string(),
            securityCode: z.string(),
        })
        .transform((v) => {
            return {
                token: v.token,
                securityCode: v.securityCode,
            };
        });

    export type Outbound = {
        token: string;
        securityCode: string;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, EmailLoginResponseBody1> = z
        .object({
            token: z.string(),
            securityCode: z.string(),
        })
        .transform((v) => {
            return {
                token: v.token,
                securityCode: v.securityCode,
            };
        });
}

/** @internal */
export namespace EmailLoginResponseBody$ {
    export const inboundSchema: z.ZodType<EmailLoginResponseBody, z.ZodTypeDef, unknown> = z.union([
        z.lazy(() => EmailLoginResponseBody1$.inboundSchema),
        z.lazy(() => EmailLoginResponseBody2$.inboundSchema),
    ]);

    export type Outbound = EmailLoginResponseBody1$.Outbound | EmailLoginResponseBody2$.Outbound;
    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, EmailLoginResponseBody> =
        z.union([
            z.lazy(() => EmailLoginResponseBody1$.outboundSchema),
            z.lazy(() => EmailLoginResponseBody2$.outboundSchema),
        ]);
}

/** @internal */
export namespace EmailLoginResponse$ {
    export const inboundSchema: z.ZodType<EmailLoginResponse, z.ZodTypeDef, unknown> = z
        .object({
            HttpMeta: HTTPMetadata$.inboundSchema,
            oneOf: z
                .union([
                    z.lazy(() => EmailLoginResponseBody1$.inboundSchema),
                    z.lazy(() => EmailLoginResponseBody2$.inboundSchema),
                ])
                .optional(),
        })
        .transform((v) => {
            return {
                httpMeta: v.HttpMeta,
                ...(v.oneOf === undefined ? null : { oneOf: v.oneOf }),
            };
        });

    export type Outbound = {
        HttpMeta: HTTPMetadata$.Outbound;
        oneOf?: EmailLoginResponseBody1$.Outbound | EmailLoginResponseBody2$.Outbound | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, EmailLoginResponse> = z
        .object({
            httpMeta: HTTPMetadata$.outboundSchema,
            oneOf: z
                .union([
                    z.lazy(() => EmailLoginResponseBody1$.outboundSchema),
                    z.lazy(() => EmailLoginResponseBody2$.outboundSchema),
                ])
                .optional(),
        })
        .transform((v) => {
            return {
                HttpMeta: v.httpMeta,
                ...(v.oneOf === undefined ? null : { oneOf: v.oneOf }),
            };
        });
}
