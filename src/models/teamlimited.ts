/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as z from "zod";

/**
 * Information for the SAML Single Sign-On configuration.
 */
export type Connection = {
    /**
     * The Identity Provider "type", for example Okta.
     */
    type: string;
    /**
     * Current status of the connection.
     */
    status: string;
    /**
     * Current state of the connection.
     */
    state: string;
    /**
     * Timestamp (in milliseconds) of when the configuration was connected.
     */
    connectedAt: number;
    /**
     * Timestamp (in milliseconds) of when the last webhook event was received from WorkOS.
     */
    lastReceivedWebhookEvent?: number | undefined;
};

/**
 * Information for the SAML Single Sign-On configuration.
 */
export type Directory = {
    /**
     * The Identity Provider "type", for example Okta.
     */
    type: string;
    /**
     * Current status of the connection.
     */
    status: string;
    /**
     * Current state of the connection.
     */
    state: string;
    /**
     * Timestamp (in milliseconds) of when the configuration was connected.
     */
    connectedAt: number;
    /**
     * Timestamp (in milliseconds) of when the last webhook event was received from WorkOS.
     */
    lastReceivedWebhookEvent?: number | undefined;
};

/**
 * When "Single Sign-On (SAML)" is configured, this object contains information that allows the client-side to identify whether or not this Team has SAML enforced.
 */
export type Saml = {
    /**
     * Information for the SAML Single Sign-On configuration.
     */
    connection?: Connection | undefined;
    /**
     * Information for the SAML Single Sign-On configuration.
     */
    directory?: Directory | undefined;
    /**
     * When `true`, interactions with the Team **must** be done with an authentication token that has been authenticated with the Team's SAML Single Sign-On provider.
     */
    enforced: boolean;
};

export enum MembershipRole {
    Owner = "OWNER",
    Member = "MEMBER",
    Developer = "DEVELOPER",
    Billing = "BILLING",
    Viewer = "VIEWER",
    Contributor = "CONTRIBUTOR",
}

export enum MembershipOrigin {
    Link = "link",
    Saml = "saml",
    Mail = "mail",
    Import = "import",
    Teams = "teams",
    Github = "github",
    Gitlab = "gitlab",
    Bitbucket = "bitbucket",
    Dsync = "dsync",
    Feedback = "feedback",
    OrganizationTeams = "organization-teams",
}

export type MembershipGitUserId = string | number;

export type MembershipJoinedFrom = {
    origin: MembershipOrigin;
    commitId?: string | undefined;
    repoId?: string | undefined;
    repoPath?: string | undefined;
    gitUserId?: string | number | undefined;
    gitUserLogin?: string | undefined;
    ssoUserId?: string | undefined;
    ssoConnectedAt?: number | undefined;
    idpUserId?: string | undefined;
    dsyncUserId?: string | undefined;
    dsyncConnectedAt?: number | undefined;
};

/**
 * The membership of the authenticated User in relation to the Team.
 */
export type Two = {
    confirmed: boolean;
    confirmedAt?: number | undefined;
    accessRequestedAt: number;
    role: MembershipRole;
    teamId?: string | undefined;
    uid: string;
    createdAt: number;
    created: number;
    joinedFrom?: MembershipJoinedFrom | undefined;
};

export enum Role {
    Owner = "OWNER",
    Member = "MEMBER",
    Developer = "DEVELOPER",
    Billing = "BILLING",
    Viewer = "VIEWER",
    Contributor = "CONTRIBUTOR",
}

export enum TeamLimitedMembershipOrigin {
    Link = "link",
    Saml = "saml",
    Mail = "mail",
    Import = "import",
    Teams = "teams",
    Github = "github",
    Gitlab = "gitlab",
    Bitbucket = "bitbucket",
    Dsync = "dsync",
    Feedback = "feedback",
    OrganizationTeams = "organization-teams",
}

export type GitUserId = string | number;

export type JoinedFrom = {
    origin: TeamLimitedMembershipOrigin;
    commitId?: string | undefined;
    repoId?: string | undefined;
    repoPath?: string | undefined;
    gitUserId?: string | number | undefined;
    gitUserLogin?: string | undefined;
    ssoUserId?: string | undefined;
    ssoConnectedAt?: number | undefined;
    idpUserId?: string | undefined;
    dsyncUserId?: string | undefined;
    dsyncConnectedAt?: number | undefined;
};

/**
 * The membership of the authenticated User in relation to the Team.
 */
export type One = {
    confirmed: boolean;
    confirmedAt: number;
    accessRequestedAt?: number | undefined;
    role: Role;
    teamId?: string | undefined;
    uid: string;
    createdAt: number;
    created: number;
    joinedFrom?: JoinedFrom | undefined;
};

export type Membership = One | Two;

/**
 * A limited form of data representing a Team, due to the authentication token missing privileges to read the full Team data.
 */
export type TeamLimited = {
    /**
     * Property indicating that this Team data contains only limited information, due to the authentication token missing privileges to read the full Team data. Re-login with the Team's configured SAML Single Sign-On provider in order to upgrade the authentication token with the necessary privileges.
     */
    limited: boolean;
    /**
     * When "Single Sign-On (SAML)" is configured, this object contains information that allows the client-side to identify whether or not this Team has SAML enforced.
     */
    saml?: Saml | undefined;
    /**
     * The Team's unique identifier.
     */
    id: string;
    /**
     * The Team's slug, which is unique across the Vercel platform.
     */
    slug: string;
    /**
     * Name associated with the Team account, or `null` if none has been provided.
     */
    name: string | null;
    /**
     * The ID of the file used as avatar for this Team.
     */
    avatar: string | null;
    membership: One | Two;
    /**
     * Will remain undocumented. Remove in v3 API.
     */
    created: string;
    /**
     * UNIX timestamp (in milliseconds) when the Team was created.
     */
    createdAt: number;
};

/** @internal */
export namespace Connection$ {
    export const inboundSchema: z.ZodType<Connection, z.ZodTypeDef, unknown> = z.object({
        type: z.string(),
        status: z.string(),
        state: z.string(),
        connectedAt: z.number(),
        lastReceivedWebhookEvent: z.number().optional(),
    });

    export type Outbound = {
        type: string;
        status: string;
        state: string;
        connectedAt: number;
        lastReceivedWebhookEvent?: number | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Connection> = z.object({
        type: z.string(),
        status: z.string(),
        state: z.string(),
        connectedAt: z.number(),
        lastReceivedWebhookEvent: z.number().optional(),
    });
}

/** @internal */
export namespace Directory$ {
    export const inboundSchema: z.ZodType<Directory, z.ZodTypeDef, unknown> = z.object({
        type: z.string(),
        status: z.string(),
        state: z.string(),
        connectedAt: z.number(),
        lastReceivedWebhookEvent: z.number().optional(),
    });

    export type Outbound = {
        type: string;
        status: string;
        state: string;
        connectedAt: number;
        lastReceivedWebhookEvent?: number | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Directory> = z.object({
        type: z.string(),
        status: z.string(),
        state: z.string(),
        connectedAt: z.number(),
        lastReceivedWebhookEvent: z.number().optional(),
    });
}

/** @internal */
export namespace Saml$ {
    export const inboundSchema: z.ZodType<Saml, z.ZodTypeDef, unknown> = z.object({
        connection: z.lazy(() => Connection$.inboundSchema).optional(),
        directory: z.lazy(() => Directory$.inboundSchema).optional(),
        enforced: z.boolean(),
    });

    export type Outbound = {
        connection?: Connection$.Outbound | undefined;
        directory?: Directory$.Outbound | undefined;
        enforced: boolean;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Saml> = z.object({
        connection: z.lazy(() => Connection$.outboundSchema).optional(),
        directory: z.lazy(() => Directory$.outboundSchema).optional(),
        enforced: z.boolean(),
    });
}

/** @internal */
export namespace MembershipRole$ {
    export const inboundSchema = z.nativeEnum(MembershipRole);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace MembershipOrigin$ {
    export const inboundSchema = z.nativeEnum(MembershipOrigin);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace MembershipGitUserId$ {
    export const inboundSchema: z.ZodType<MembershipGitUserId, z.ZodTypeDef, unknown> = z.union([
        z.string(),
        z.number(),
    ]);

    export type Outbound = string | number;
    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, MembershipGitUserId> = z.union([
        z.string(),
        z.number(),
    ]);
}

/** @internal */
export namespace MembershipJoinedFrom$ {
    export const inboundSchema: z.ZodType<MembershipJoinedFrom, z.ZodTypeDef, unknown> = z.object({
        origin: MembershipOrigin$.inboundSchema,
        commitId: z.string().optional(),
        repoId: z.string().optional(),
        repoPath: z.string().optional(),
        gitUserId: z.union([z.string(), z.number()]).optional(),
        gitUserLogin: z.string().optional(),
        ssoUserId: z.string().optional(),
        ssoConnectedAt: z.number().optional(),
        idpUserId: z.string().optional(),
        dsyncUserId: z.string().optional(),
        dsyncConnectedAt: z.number().optional(),
    });

    export type Outbound = {
        origin: string;
        commitId?: string | undefined;
        repoId?: string | undefined;
        repoPath?: string | undefined;
        gitUserId?: string | number | undefined;
        gitUserLogin?: string | undefined;
        ssoUserId?: string | undefined;
        ssoConnectedAt?: number | undefined;
        idpUserId?: string | undefined;
        dsyncUserId?: string | undefined;
        dsyncConnectedAt?: number | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, MembershipJoinedFrom> = z.object(
        {
            origin: MembershipOrigin$.outboundSchema,
            commitId: z.string().optional(),
            repoId: z.string().optional(),
            repoPath: z.string().optional(),
            gitUserId: z.union([z.string(), z.number()]).optional(),
            gitUserLogin: z.string().optional(),
            ssoUserId: z.string().optional(),
            ssoConnectedAt: z.number().optional(),
            idpUserId: z.string().optional(),
            dsyncUserId: z.string().optional(),
            dsyncConnectedAt: z.number().optional(),
        }
    );
}

/** @internal */
export namespace Two$ {
    export const inboundSchema: z.ZodType<Two, z.ZodTypeDef, unknown> = z.object({
        confirmed: z.boolean(),
        confirmedAt: z.number().optional(),
        accessRequestedAt: z.number(),
        role: MembershipRole$.inboundSchema,
        teamId: z.string().optional(),
        uid: z.string(),
        createdAt: z.number(),
        created: z.number(),
        joinedFrom: z.lazy(() => MembershipJoinedFrom$.inboundSchema).optional(),
    });

    export type Outbound = {
        confirmed: boolean;
        confirmedAt?: number | undefined;
        accessRequestedAt: number;
        role: string;
        teamId?: string | undefined;
        uid: string;
        createdAt: number;
        created: number;
        joinedFrom?: MembershipJoinedFrom$.Outbound | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Two> = z.object({
        confirmed: z.boolean(),
        confirmedAt: z.number().optional(),
        accessRequestedAt: z.number(),
        role: MembershipRole$.outboundSchema,
        teamId: z.string().optional(),
        uid: z.string(),
        createdAt: z.number(),
        created: z.number(),
        joinedFrom: z.lazy(() => MembershipJoinedFrom$.outboundSchema).optional(),
    });
}

/** @internal */
export namespace Role$ {
    export const inboundSchema = z.nativeEnum(Role);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace TeamLimitedMembershipOrigin$ {
    export const inboundSchema = z.nativeEnum(TeamLimitedMembershipOrigin);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace GitUserId$ {
    export const inboundSchema: z.ZodType<GitUserId, z.ZodTypeDef, unknown> = z.union([
        z.string(),
        z.number(),
    ]);

    export type Outbound = string | number;
    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, GitUserId> = z.union([
        z.string(),
        z.number(),
    ]);
}

/** @internal */
export namespace JoinedFrom$ {
    export const inboundSchema: z.ZodType<JoinedFrom, z.ZodTypeDef, unknown> = z.object({
        origin: TeamLimitedMembershipOrigin$.inboundSchema,
        commitId: z.string().optional(),
        repoId: z.string().optional(),
        repoPath: z.string().optional(),
        gitUserId: z.union([z.string(), z.number()]).optional(),
        gitUserLogin: z.string().optional(),
        ssoUserId: z.string().optional(),
        ssoConnectedAt: z.number().optional(),
        idpUserId: z.string().optional(),
        dsyncUserId: z.string().optional(),
        dsyncConnectedAt: z.number().optional(),
    });

    export type Outbound = {
        origin: string;
        commitId?: string | undefined;
        repoId?: string | undefined;
        repoPath?: string | undefined;
        gitUserId?: string | number | undefined;
        gitUserLogin?: string | undefined;
        ssoUserId?: string | undefined;
        ssoConnectedAt?: number | undefined;
        idpUserId?: string | undefined;
        dsyncUserId?: string | undefined;
        dsyncConnectedAt?: number | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, JoinedFrom> = z.object({
        origin: TeamLimitedMembershipOrigin$.outboundSchema,
        commitId: z.string().optional(),
        repoId: z.string().optional(),
        repoPath: z.string().optional(),
        gitUserId: z.union([z.string(), z.number()]).optional(),
        gitUserLogin: z.string().optional(),
        ssoUserId: z.string().optional(),
        ssoConnectedAt: z.number().optional(),
        idpUserId: z.string().optional(),
        dsyncUserId: z.string().optional(),
        dsyncConnectedAt: z.number().optional(),
    });
}

/** @internal */
export namespace One$ {
    export const inboundSchema: z.ZodType<One, z.ZodTypeDef, unknown> = z.object({
        confirmed: z.boolean(),
        confirmedAt: z.number(),
        accessRequestedAt: z.number().optional(),
        role: Role$.inboundSchema,
        teamId: z.string().optional(),
        uid: z.string(),
        createdAt: z.number(),
        created: z.number(),
        joinedFrom: z.lazy(() => JoinedFrom$.inboundSchema).optional(),
    });

    export type Outbound = {
        confirmed: boolean;
        confirmedAt: number;
        accessRequestedAt?: number | undefined;
        role: string;
        teamId?: string | undefined;
        uid: string;
        createdAt: number;
        created: number;
        joinedFrom?: JoinedFrom$.Outbound | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, One> = z.object({
        confirmed: z.boolean(),
        confirmedAt: z.number(),
        accessRequestedAt: z.number().optional(),
        role: Role$.outboundSchema,
        teamId: z.string().optional(),
        uid: z.string(),
        createdAt: z.number(),
        created: z.number(),
        joinedFrom: z.lazy(() => JoinedFrom$.outboundSchema).optional(),
    });
}

/** @internal */
export namespace Membership$ {
    export const inboundSchema: z.ZodType<Membership, z.ZodTypeDef, unknown> = z.union([
        z.lazy(() => One$.inboundSchema),
        z.lazy(() => Two$.inboundSchema),
    ]);

    export type Outbound = One$.Outbound | Two$.Outbound;
    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Membership> = z.union([
        z.lazy(() => One$.outboundSchema),
        z.lazy(() => Two$.outboundSchema),
    ]);
}

/** @internal */
export namespace TeamLimited$ {
    export const inboundSchema: z.ZodType<TeamLimited, z.ZodTypeDef, unknown> = z.object({
        limited: z.boolean(),
        saml: z.lazy(() => Saml$.inboundSchema).optional(),
        id: z.string(),
        slug: z.string(),
        name: z.nullable(z.string()),
        avatar: z.nullable(z.string()),
        membership: z.union([z.lazy(() => One$.inboundSchema), z.lazy(() => Two$.inboundSchema)]),
        created: z.string(),
        createdAt: z.number(),
    });

    export type Outbound = {
        limited: boolean;
        saml?: Saml$.Outbound | undefined;
        id: string;
        slug: string;
        name: string | null;
        avatar: string | null;
        membership: One$.Outbound | Two$.Outbound;
        created: string;
        createdAt: number;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, TeamLimited> = z.object({
        limited: z.boolean(),
        saml: z.lazy(() => Saml$.outboundSchema).optional(),
        id: z.string(),
        slug: z.string(),
        name: z.nullable(z.string()),
        avatar: z.nullable(z.string()),
        membership: z.union([z.lazy(() => One$.outboundSchema), z.lazy(() => Two$.outboundSchema)]),
        created: z.string(),
        createdAt: z.number(),
    });
}
