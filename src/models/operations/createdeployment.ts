/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as components from "../components";
import * as z from "zod";

/**
 * Forces a new deployment even if there is a previous similar deployment
 */
export enum ForceNew {
    Zero = "0",
    One = "1",
}

/**
 * Allows to skip framework detection so the API would not fail to ask for confirmation
 */
export enum SkipAutoDetectionConfirmation {
    Zero = "0",
    One = "1",
}

/**
 * Used in the case you want to reference a file that was already uploaded
 */
export type UploadedFile = {
    /**
     * The file path relative to the project root
     */
    file: string;
    /**
     * The file contents hashed with SHA1, used to check the integrity
     */
    sha?: string | undefined;
    /**
     * The file size in bytes
     */
    size?: number | undefined;
};

/**
 * The file content encoding, it could be either a base64 (useful for images, etc.) of the files or the plain text for source code.
 */
export enum Encoding {
    Base64 = "base64",
    Utf8 = "utf-8",
}

/**
 * Used in the case you want to inline a file inside the request
 */
export type InlinedFile = {
    /**
     * The file content, it could be either a `base64` (useful for images, etc.) of the files or the plain content for source code
     */
    data: string;
    /**
     * The file content encoding, it could be either a base64 (useful for images, etc.) of the files or the plain text for source code.
     */
    encoding?: Encoding | undefined;
    /**
     * The file name including the whole path
     */
    file: string;
};

export type Files = InlinedFile | UploadedFile;

/**
 * Populates initial git metadata for different git providers.
 */
export type GitMetadata = {
    /**
     * The git repository's remote origin url
     */
    remoteUrl?: string | undefined;
    /**
     * The name of the author of the commit
     */
    commitAuthorName?: string | undefined;
    /**
     * The commit message
     */
    commitMessage?: string | undefined;
    /**
     * The branch on which the commit was made
     */
    commitRef?: string | undefined;
    /**
     * The hash of the commit
     */
    commitSha?: string | undefined;
    /**
     * Whether or not there have been modifications to the working tree since the latest commit
     */
    dirty?: boolean | undefined;
};

export enum CreateDeploymentGitSourceDeploymentsRequestType {
    Bitbucket = "bitbucket",
}

export type Five = {
    owner: string;
    ref: string;
    sha?: string | undefined;
    slug: string;
    type: CreateDeploymentGitSourceDeploymentsRequestType;
};

export enum CreateDeploymentGitSourceDeploymentsType {
    Bitbucket = "bitbucket",
}

export type Four = {
    ref: string;
    repoUuid: string;
    sha?: string | undefined;
    type: CreateDeploymentGitSourceDeploymentsType;
    workspaceUuid?: string | undefined;
};

export type ProjectId = number | string;

export enum CreateDeploymentGitSourceType {
    Gitlab = "gitlab",
}

export type Three = {
    projectId: number | string;
    ref: string;
    sha?: string | undefined;
    type: CreateDeploymentGitSourceType;
};

export enum GitSourceType {
    Github = "github",
}

export type Two = {
    org: string;
    ref: string;
    repo: string;
    sha?: string | undefined;
    type: GitSourceType;
};

export type RepoId = number | string;

export enum Type {
    Github = "github",
}

export type One = {
    ref: string;
    repoId: number | string;
    sha?: string | undefined;
    type: Type;
};

/**
 * Defines the Git Repository source to be deployed. This property can not be used in combination with `files`.
 */
export type GitSource = One | Three | Two | Four | Five;

/**
 * The framework that is being used for this project. When `null` is used no framework is selected
 */
export enum Framework {
    Blitzjs = "blitzjs",
    Nextjs = "nextjs",
    Gatsby = "gatsby",
    Remix = "remix",
    Astro = "astro",
    Hexo = "hexo",
    Eleventy = "eleventy",
    Docusaurus2 = "docusaurus-2",
    Docusaurus = "docusaurus",
    Preact = "preact",
    Solidstart1 = "solidstart-1",
    Solidstart = "solidstart",
    Dojo = "dojo",
    Ember = "ember",
    Vue = "vue",
    Scully = "scully",
    IonicAngular = "ionic-angular",
    Angular = "angular",
    Polymer = "polymer",
    Svelte = "svelte",
    Sveltekit = "sveltekit",
    Sveltekit1 = "sveltekit-1",
    IonicReact = "ionic-react",
    CreateReactApp = "create-react-app",
    Gridsome = "gridsome",
    Umijs = "umijs",
    Sapper = "sapper",
    Saber = "saber",
    Stencil = "stencil",
    Nuxtjs = "nuxtjs",
    Redwoodjs = "redwoodjs",
    Hugo = "hugo",
    Jekyll = "jekyll",
    Brunch = "brunch",
    Middleman = "middleman",
    Zola = "zola",
    Hydrogen = "hydrogen",
    Vite = "vite",
    Vitepress = "vitepress",
    Vuepress = "vuepress",
    Parcel = "parcel",
    Sanity = "sanity",
    Storybook = "storybook",
}

/**
 * Override the Node.js version that should be used for this deployment
 */
export enum NodeVersion {
    TwentyX = "20.x",
    EighteenX = "18.x",
    SixteenX = "16.x",
}

/**
 * Project settings that will be applied to the deployment. It is required for the first deployment of a project and will be saved for any following deployments
 */
export type ProjectSettings = {
    /**
     * The build command for this project. When `null` is used this value will be automatically detected
     */
    buildCommand?: string | null | undefined;
    commandForIgnoringBuildStep?: string | null | undefined;
    /**
     * The dev command for this project. When `null` is used this value will be automatically detected
     */
    devCommand?: string | null | undefined;
    /**
     * The framework that is being used for this project. When `null` is used no framework is selected
     */
    framework?: Framework | null | undefined;
    /**
     * The install command for this project. When `null` is used this value will be automatically detected
     */
    installCommand?: string | null | undefined;
    /**
     * Override the Node.js version that should be used for this deployment
     */
    nodeVersion?: NodeVersion | undefined;
    /**
     * The output directory of the project. When `null` is used this value will be automatically detected
     */
    outputDirectory?: string | null | undefined;
    /**
     * The name of a directory or relative path to the source code of your project. When `null` is used it will default to the project root
     */
    rootDirectory?: string | null | undefined;
    /**
     * The region to deploy Serverless Functions in this project
     */
    serverlessFunctionRegion?: string | null | undefined;
    /**
     * Opts-out of the message prompting a CLI user to connect a Git repository in `vercel link`.
     *
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    skipGitConnectDuringLink?: boolean | undefined;
    /**
     * Indicates if there are source files outside of the root directory, typically used for monorepos
     */
    sourceFilesOutsideRootDirectory?: boolean | undefined;
};

/**
 * Either not defined, `staging`, or `production`. If `staging`, a staging alias in the format `<project>-<team>.vercel.app` will be assigned. If `production`, any aliases defined in `alias` will be assigned. If omitted, the target will be `preview`
 */
export enum Target {
    Staging = "staging",
    Production = "production",
}

export type CreateDeploymentRequestBody = {
    /**
     * Deploy to a custom environment, which will override the default environment
     */
    customEnvironmentSlugOrId?: string | undefined;
    /**
     * An deployment id for an existing deployment to redeploy
     */
    deploymentId?: string | undefined;
    /**
     * A list of objects with the files to be deployed
     */
    files?: Array<InlinedFile | UploadedFile> | undefined;
    /**
     * Populates initial git metadata for different git providers.
     */
    gitMetadata?: GitMetadata | undefined;
    /**
     * Defines the Git Repository source to be deployed. This property can not be used in combination with `files`.
     */
    gitSource?: One | Three | Two | Four | Five | undefined;
    /**
     * An object containing the deployment's metadata. Multiple key-value pairs can be attached to a deployment
     */
    meta?: Record<string, string> | undefined;
    /**
     * The monorepo manager that is being used for this deployment. When `null` is used no monorepo manager is selected
     */
    monorepoManager?: string | null | undefined;
    /**
     * A string with the project name used in the deployment URL
     */
    name: string;
    /**
     * The target project identifier in which the deployment will be created. When defined, this parameter overrides name
     */
    project?: string | undefined;
    /**
     * Project settings that will be applied to the deployment. It is required for the first deployment of a project and will be saved for any following deployments
     */
    projectSettings?: ProjectSettings | undefined;
    /**
     * Either not defined, `staging`, or `production`. If `staging`, a staging alias in the format `<project>-<team>.vercel.app` will be assigned. If `production`, any aliases defined in `alias` will be assigned. If omitted, the target will be `preview`
     */
    target?: Target | undefined;
    /**
     * When `true` and `deploymentId` is passed in, the sha from the previous deployment's `gitSource` is removed forcing the latest commit to be used.
     */
    withLatestCommit?: boolean | undefined;
};

export type CreateDeploymentRequest = {
    /**
     * Forces a new deployment even if there is a previous similar deployment
     */
    forceNew?: ForceNew | undefined;
    /**
     * Allows to skip framework detection so the API would not fail to ask for confirmation
     */
    skipAutoDetectionConfirmation?: SkipAutoDetectionConfirmation | undefined;
    /**
     * The Team identifier to perform the request on behalf of.
     */
    teamId?: string | undefined;
    /**
     * The Team slug to perform the request on behalf of.
     */
    slug?: string | undefined;
    requestBody?: CreateDeploymentRequestBody | undefined;
};

export type Build = {
    /**
     * The keys of the environment variables that were assigned during the build phase.
     */
    env: Array<string>;
};

export type CreateDeploymentBuilds = {};

/**
 * The cron jobs associated with this deployment. Note that preview deployments are also allowed to have this property, but only production deployments create cron jobs. If a preview deployment is promoted to production, only then they'll take effect.
 */
export type CreateDeploymentCrons = {
    schedule: string;
    path: string;
};

/**
 * An object used to configure your Serverless Functions
 */
export type Functions = {
    memory?: number | undefined;
    maxDuration?: number | undefined;
    runtime?: string | undefined;
    includeFiles?: string | undefined;
    excludeFiles?: string | undefined;
};

/**
 * The pricing plan the deployment was made under
 */
export enum Plan {
    Pro = "pro",
    Enterprise = "enterprise",
    Hobby = "hobby",
}

/**
 * A list of routes objects used to rewrite paths to point towards other internal or external paths
 */
export type Routes3 = {
    src: string;
    continue: boolean;
    middleware: number;
};

export enum RoutesHandle {
    Error = "error",
    Filesystem = "filesystem",
    Hit = "hit",
    Miss = "miss",
    Resource = "resource",
    Rewrite = "rewrite",
}

/**
 * A list of routes objects used to rewrite paths to point towards other internal or external paths
 */
export type Routes2 = {
    handle: RoutesHandle;
    src?: string | undefined;
    dest?: string | undefined;
    status?: number | undefined;
};

export enum CreateDeploymentHasType {
    Header = "header",
    Cookie = "cookie",
    Query = "query",
}

export type Has2 = {
    type: CreateDeploymentHasType;
    key: string;
    value?: string | undefined;
};

export enum HasType {
    Host = "host",
}

export type Has1 = {
    type: HasType;
    value: string;
};

export type RoutesHas = Has1 | Has2;

export enum CreateDeploymentMissingType {
    Header = "header",
    Cookie = "cookie",
    Query = "query",
}

export type Missing2 = {
    type: CreateDeploymentMissingType;
    key: string;
    value?: string | undefined;
};

export enum MissingType {
    Host = "host",
}

export type Missing1 = {
    type: MissingType;
    value: string;
};

export type RoutesMissing = Missing1 | Missing2;

export type Locale = {
    redirect?: Record<string, string> | undefined;
    cookie?: string | undefined;
};

/**
 * A list of routes objects used to rewrite paths to point towards other internal or external paths
 */
export type Routes1 = {
    src: string;
    dest?: string | undefined;
    headers?: Record<string, string> | undefined;
    methods?: Array<string> | undefined;
    continue?: boolean | undefined;
    override?: boolean | undefined;
    caseSensitive?: boolean | undefined;
    check?: boolean | undefined;
    important?: boolean | undefined;
    status?: number | undefined;
    has?: Array<Has1 | Has2> | undefined;
    missing?: Array<Missing1 | Missing2> | undefined;
    locale?: Locale | undefined;
    /**
     * A middleware key within the `output` key under the build result. Overrides a `middleware` definition.
     */
    middlewarePath?: string | undefined;
    /**
     * The original middleware matchers.
     */
    middlewareRawSrc?: Array<string> | undefined;
    /**
     * A middleware index in the `middleware` key under the build result
     */
    middleware?: number | undefined;
};

export type Routes = Routes3 | Routes2 | Routes1;

export enum CreateDeploymentGitRepoDeploymentsType {
    Bitbucket = "bitbucket",
}

export enum CreateDeploymentGitRepoOwnerType {
    User = "user",
    Team = "team",
}

export type GitRepo3 = {
    owner: string;
    repoUuid: string;
    slug: string;
    type: CreateDeploymentGitRepoDeploymentsType;
    workspaceUuid: string;
    path: string;
    defaultBranch: string;
    name: string;
    private: boolean;
    ownerType: CreateDeploymentGitRepoOwnerType;
};

export enum CreateDeploymentGitRepoType {
    Github = "github",
}

export enum GitRepoOwnerType {
    User = "user",
    Team = "team",
}

export type GitRepo2 = {
    org: string;
    repo: string;
    repoId: number;
    type: CreateDeploymentGitRepoType;
    repoOwnerId: string;
    path: string;
    defaultBranch: string;
    name: string;
    private: boolean;
    ownerType: GitRepoOwnerType;
};

export enum GitRepoType {
    Gitlab = "gitlab",
}

export enum CreateDeploymentGitRepoDeploymentsOwnerType {
    User = "user",
    Team = "team",
}

export type GitRepo1 = {
    namespace: string;
    projectId: number;
    type: GitRepoType;
    url: string;
    path: string;
    defaultBranch: string;
    name: string;
    private: boolean;
    ownerType: CreateDeploymentGitRepoDeploymentsOwnerType;
};

export type GitRepo = GitRepo1 | GitRepo2 | GitRepo3;

export type AliasAssignedAt = number | boolean;

export enum CreateDeploymentDeploymentsReadyState {
    Error = "ERROR",
    Building = "BUILDING",
    Initializing = "INITIALIZING",
    Ready = "READY",
}

export type CreateDeploymentOutput = {
    path: string;
    functionName: string;
};

export type Lambdas = {
    id: string;
    createdAt?: number | undefined;
    entrypoint?: string | null | undefined;
    readyState?: CreateDeploymentDeploymentsReadyState | undefined;
    readyStateAt?: number | undefined;
    output: Array<CreateDeploymentOutput>;
};

/**
 * The public project information associated with the deployment.
 */
export type Project = {
    id: string;
    name: string;
    framework?: string | null | undefined;
};

/**
 * The state of the deployment depending on the process of deploying, or if it is ready or in an error state
 */
export enum CreateDeploymentReadyState {
    Canceled = "CANCELED",
    Error = "ERROR",
    Queued = "QUEUED",
    Building = "BUILDING",
    Initializing = "INITIALIZING",
    Ready = "READY",
}

/**
 * The substate of the deployment when the state is "READY"
 */
export enum ReadySubstate {
    Staged = "STAGED",
    Promoted = "PROMOTED",
}

/**
 * Where was the deployment created from
 */
export enum CreateDeploymentSource {
    Cli = "cli",
    Git = "git",
    Import = "import",
    ImportRepo = "import/repo",
    CloneRepo = "clone/repo",
    ApiTriggerGitDeploy = "api-trigger-git-deploy",
}

/**
 * If defined, either `staging` if a staging alias in the format `<project>.<team>.now.sh` was assigned upon creation, or `production` if the aliases from `alias` were assigned
 */
export enum CreateDeploymentTarget {
    Staging = "staging",
    Production = "production",
}

/**
 * The team that owns the deployment if any
 */
export type Team = {
    /**
     * The ID of the team owner
     */
    id: string;
    /**
     * The name of the team owner
     */
    name: string;
    /**
     * The slug of the team owner
     */
    slug: string;
    /**
     * The avatar of the team owner
     */
    avatar?: string | undefined;
};

export enum CreateDeploymentType {
    Lambdas = "LAMBDAS",
}

/**
 * An object that will contain a `code` and a `message` when the aliasing fails, otherwise the value will be `null`
 */
export type AliasError = {
    code: string;
    message: string;
};

export type AliasWarning = {
    code: string;
    message: string;
    link?: string | undefined;
    action?: string | undefined;
};

export enum ChecksState {
    Registered = "registered",
    Running = "running",
    Completed = "completed",
}

export enum ChecksConclusion {
    Succeeded = "succeeded",
    Failed = "failed",
    Skipped = "skipped",
    Canceled = "canceled",
}

/**
 * Information about the deployment creator
 */
export type Creator = {
    /**
     * The ID of the user that created the deployment
     */
    uid: string;
    /**
     * The username of the user that created the deployment
     */
    username?: string | undefined;
    /**
     * The avatar of the user that created the deployment
     */
    avatar?: string | undefined;
};

export enum CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type {
    Bitbucket = "bitbucket",
}

export type CreateDeploymentGitSource9 = {
    type: CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type;
    ref: string;
    sha: string;
    owner?: string | undefined;
    slug?: string | undefined;
    workspaceUuid: string;
    repoUuid: string;
};

export enum CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type {
    Gitlab = "gitlab",
}

export type CreateDeploymentGitSource8 = {
    type: CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type;
    ref: string;
    sha: string;
    projectId: number;
};

export enum CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type {
    Github = "github",
}

export type CreateDeploymentGitSource7 = {
    type: CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type;
    ref: string;
    sha: string;
    repoId: number;
    org?: string | undefined;
    repo?: string | undefined;
};

export enum CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type {
    Custom = "custom",
}

export type CreateDeploymentGitSource6 = {
    type: CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type;
    ref: string;
    sha: string;
    gitUrl: string;
};

export enum CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type {
    Bitbucket = "bitbucket",
}

export type GitSource5 = {
    type: CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type;
    owner: string;
    slug: string;
    ref?: string | null | undefined;
    sha?: string | undefined;
    prId?: number | null | undefined;
};

export enum CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType {
    Bitbucket = "bitbucket",
}

export type GitSource4 = {
    type: CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType;
    workspaceUuid?: string | undefined;
    repoUuid: string;
    ref?: string | null | undefined;
    sha?: string | undefined;
    prId?: number | null | undefined;
};

export enum CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType {
    Gitlab = "gitlab",
}

export type GitSourceProjectId = string | number;

export type GitSource3 = {
    type: CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType;
    projectId: string | number;
    ref?: string | null | undefined;
    sha?: string | undefined;
    prId?: number | null | undefined;
};

export enum CreateDeploymentGitSourceDeploymentsResponse200Type {
    Github = "github",
}

export type GitSource2 = {
    type: CreateDeploymentGitSourceDeploymentsResponse200Type;
    org: string;
    repo: string;
    ref?: string | null | undefined;
    sha?: string | undefined;
    prId?: number | null | undefined;
};

export enum CreateDeploymentGitSourceDeploymentsResponseType {
    Github = "github",
}

export type GitSourceRepoId = string | number;

export type GitSource1 = {
    type: CreateDeploymentGitSourceDeploymentsResponseType;
    repoId: string | number;
    ref?: string | null | undefined;
    sha?: string | undefined;
    prId?: number | null | undefined;
};

export type CreateDeploymentGitSource =
    | CreateDeploymentGitSource6
    | CreateDeploymentGitSource8
    | GitSource1
    | GitSource3
    | GitSource2
    | GitSource4
    | GitSource5
    | CreateDeploymentGitSource7
    | CreateDeploymentGitSource9;

/**
 * The successfully created deployment
 */
export type CreateDeploymentResponseBody = {
    build: Build;
    builds?: Array<CreateDeploymentBuilds> | undefined;
    /**
     * The flag saying if Vercel Connect configuration is used for builds
     */
    connectBuildsEnabled?: boolean | undefined;
    /**
     * The ID of Vercel Connect configuration used for this deployment
     */
    connectConfigurationId?: string | undefined;
    /**
     * The region where the deployment was first created
     */
    createdIn: string;
    /**
     * The cron jobs associated with this deployment. Note that preview deployments are also allowed to have this property, but only production deployments create cron jobs. If a preview deployment is promoted to production, only then they'll take effect.
     */
    crons?: Array<CreateDeploymentCrons> | undefined;
    /**
     * The keys of the environment variables that were assigned during runtime
     */
    env: Array<string>;
    /**
     * An object used to configure your Serverless Functions
     */
    functions?: Record<string, Functions> | null | undefined;
    /**
     * Vercel URL to inspect the deployment.
     */
    inspectorUrl: string | null;
    /**
     * Is the deployment currently queued waiting for a Concurrent Build Slot to be available
     */
    isInConcurrentBuildsQueue: boolean;
    /**
     * An object containing the deployment's metadata
     */
    meta: Record<string, string>;
    /**
     * An monorepo manager that was used for the deployment
     */
    monorepoManager?: string | null | undefined;
    /**
     * The name of the project associated with the deployment at the time that the deployment was created
     */
    name: string;
    /**
     * The unique ID of the user or team the deployment belongs to
     */
    ownerId: string;
    /**
     * The connect configuration ID used to deploy passive lambdas into for secure compute enabled deployments.
     */
    passiveConnectConfigurationId?: string | undefined;
    /**
     * The pricing plan the deployment was made under
     */
    plan: Plan;
    /**
     * The ID of the project the deployment is associated with
     */
    projectId: string;
    /**
     * A list of routes objects used to rewrite paths to point towards other internal or external paths
     */
    routes: Array<Routes3 | Routes2 | Routes1> | null;
    gitRepo?: GitRepo1 | GitRepo2 | GitRepo3 | null | undefined;
    aliasAssignedAt?: number | boolean | null | undefined;
    lambdas?: Array<Lambdas> | undefined;
    /**
     * The public project information associated with the deployment.
     */
    project?: Project | undefined;
    /**
     * A boolean representing if the deployment is public or not. By default this is `false`
     */
    public: boolean;
    /**
     * The state of the deployment depending on the process of deploying, or if it is ready or in an error state
     */
    readyState: CreateDeploymentReadyState;
    /**
     * The substate of the deployment when the state is "READY"
     */
    readySubstate?: ReadySubstate | undefined;
    /**
     * The regions the deployment exists in
     */
    regions: Array<string>;
    /**
     * Where was the deployment created from
     */
    source?: CreateDeploymentSource | undefined;
    /**
     * If defined, either `staging` if a staging alias in the format `<project>.<team>.now.sh` was assigned upon creation, or `production` if the aliases from `alias` were assigned
     */
    target?: CreateDeploymentTarget | null | undefined;
    /**
     * The team that owns the deployment if any
     */
    team?: Team | undefined;
    type: CreateDeploymentType;
    /**
     * A string with the unique URL of the deployment
     */
    url: string;
    /**
     * An array of domains that were provided by the user when creating the Deployment.
     */
    userAliases?: Array<string> | undefined;
    /**
     * The platform version that was used to create the deployment.
     */
    version: number;
    /**
     * Whether or not preview comments are enabled for the deployment
     */
    previewCommentsEnabled?: boolean | undefined;
    /**
     * A list of all the aliases (default aliases, staging aliases and production aliases) that were assigned upon deployment creation
     */
    alias: Array<string>;
    /**
     * A boolean that will be true when the aliases from the alias property were assigned successfully
     */
    aliasAssigned: boolean;
    /**
     * An object that will contain a `code` and a `message` when the aliasing fails, otherwise the value will be `null`
     */
    aliasError?: AliasError | null | undefined;
    aliasFinal?: string | null | undefined;
    aliasWarning?: AliasWarning | null | undefined;
    autoAssignCustomDomains?: boolean | undefined;
    automaticAliases?: Array<string> | undefined;
    bootedAt: number;
    buildErrorAt?: number | undefined;
    buildingAt: number;
    canceledAt?: number | undefined;
    checksState?: ChecksState | undefined;
    checksConclusion?: ChecksConclusion | undefined;
    /**
     * A number containing the date when the deployment was created in milliseconds
     */
    createdAt: number;
    /**
     * Information about the deployment creator
     */
    creator: Creator;
    errorCode?: string | undefined;
    errorLink?: string | undefined;
    errorMessage?: string | null | undefined;
    errorStep?: string | undefined;
    passiveRegions?: Array<string> | undefined;
    gitSource?:
        | CreateDeploymentGitSource6
        | CreateDeploymentGitSource8
        | GitSource1
        | GitSource3
        | GitSource2
        | GitSource4
        | GitSource5
        | CreateDeploymentGitSource7
        | CreateDeploymentGitSource9
        | undefined;
    /**
     * A string holding the unique ID of the deployment
     */
    id: string;
};

export type CreateDeploymentResponse = {
    httpMeta: components.HTTPMetadata;
    /**
     * The successfully created deployment
     */
    object?: CreateDeploymentResponseBody | undefined;
};

/** @internal */
export const ForceNew$: z.ZodNativeEnum<typeof ForceNew> = z.nativeEnum(ForceNew);

/** @internal */
export const SkipAutoDetectionConfirmation$: z.ZodNativeEnum<typeof SkipAutoDetectionConfirmation> =
    z.nativeEnum(SkipAutoDetectionConfirmation);

/** @internal */
export namespace UploadedFile$ {
    export const inboundSchema: z.ZodType<UploadedFile, z.ZodTypeDef, unknown> = z
        .object({
            file: z.string(),
            sha: z.string().optional(),
            size: z.number().int().optional(),
        })
        .transform((v) => {
            return {
                file: v.file,
                ...(v.sha === undefined ? null : { sha: v.sha }),
                ...(v.size === undefined ? null : { size: v.size }),
            };
        });

    export type Outbound = {
        file: string;
        sha?: string | undefined;
        size?: number | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, UploadedFile> = z
        .object({
            file: z.string(),
            sha: z.string().optional(),
            size: z.number().int().optional(),
        })
        .transform((v) => {
            return {
                file: v.file,
                ...(v.sha === undefined ? null : { sha: v.sha }),
                ...(v.size === undefined ? null : { size: v.size }),
            };
        });
}

/** @internal */
export const Encoding$: z.ZodNativeEnum<typeof Encoding> = z.nativeEnum(Encoding);

/** @internal */
export namespace InlinedFile$ {
    export const inboundSchema: z.ZodType<InlinedFile, z.ZodTypeDef, unknown> = z
        .object({
            data: z.string(),
            encoding: Encoding$.optional(),
            file: z.string(),
        })
        .transform((v) => {
            return {
                data: v.data,
                ...(v.encoding === undefined ? null : { encoding: v.encoding }),
                file: v.file,
            };
        });

    export type Outbound = {
        data: string;
        encoding?: Encoding | undefined;
        file: string;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, InlinedFile> = z
        .object({
            data: z.string(),
            encoding: Encoding$.optional(),
            file: z.string(),
        })
        .transform((v) => {
            return {
                data: v.data,
                ...(v.encoding === undefined ? null : { encoding: v.encoding }),
                file: v.file,
            };
        });
}

/** @internal */
export namespace Files$ {
    export const inboundSchema: z.ZodType<Files, z.ZodTypeDef, unknown> = z.union([
        z.lazy(() => InlinedFile$.inboundSchema),
        z.lazy(() => UploadedFile$.inboundSchema),
    ]);

    export type Outbound = InlinedFile$.Outbound | UploadedFile$.Outbound;
    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Files> = z.union([
        z.lazy(() => InlinedFile$.outboundSchema),
        z.lazy(() => UploadedFile$.outboundSchema),
    ]);
}

/** @internal */
export namespace GitMetadata$ {
    export const inboundSchema: z.ZodType<GitMetadata, z.ZodTypeDef, unknown> = z
        .object({
            remoteUrl: z.string().optional(),
            commitAuthorName: z.string().optional(),
            commitMessage: z.string().optional(),
            commitRef: z.string().optional(),
            commitSha: z.string().optional(),
            dirty: z.boolean().optional(),
        })
        .transform((v) => {
            return {
                ...(v.remoteUrl === undefined ? null : { remoteUrl: v.remoteUrl }),
                ...(v.commitAuthorName === undefined
                    ? null
                    : { commitAuthorName: v.commitAuthorName }),
                ...(v.commitMessage === undefined ? null : { commitMessage: v.commitMessage }),
                ...(v.commitRef === undefined ? null : { commitRef: v.commitRef }),
                ...(v.commitSha === undefined ? null : { commitSha: v.commitSha }),
                ...(v.dirty === undefined ? null : { dirty: v.dirty }),
            };
        });

    export type Outbound = {
        remoteUrl?: string | undefined;
        commitAuthorName?: string | undefined;
        commitMessage?: string | undefined;
        commitRef?: string | undefined;
        commitSha?: string | undefined;
        dirty?: boolean | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, GitMetadata> = z
        .object({
            remoteUrl: z.string().optional(),
            commitAuthorName: z.string().optional(),
            commitMessage: z.string().optional(),
            commitRef: z.string().optional(),
            commitSha: z.string().optional(),
            dirty: z.boolean().optional(),
        })
        .transform((v) => {
            return {
                ...(v.remoteUrl === undefined ? null : { remoteUrl: v.remoteUrl }),
                ...(v.commitAuthorName === undefined
                    ? null
                    : { commitAuthorName: v.commitAuthorName }),
                ...(v.commitMessage === undefined ? null : { commitMessage: v.commitMessage }),
                ...(v.commitRef === undefined ? null : { commitRef: v.commitRef }),
                ...(v.commitSha === undefined ? null : { commitSha: v.commitSha }),
                ...(v.dirty === undefined ? null : { dirty: v.dirty }),
            };
        });
}

/** @internal */
export const CreateDeploymentGitSourceDeploymentsRequestType$: z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsRequestType
> = z.nativeEnum(CreateDeploymentGitSourceDeploymentsRequestType);

/** @internal */
export namespace Five$ {
    export const inboundSchema: z.ZodType<Five, z.ZodTypeDef, unknown> = z
        .object({
            owner: z.string(),
            ref: z.string(),
            sha: z.string().optional(),
            slug: z.string(),
            type: CreateDeploymentGitSourceDeploymentsRequestType$,
        })
        .transform((v) => {
            return {
                owner: v.owner,
                ref: v.ref,
                ...(v.sha === undefined ? null : { sha: v.sha }),
                slug: v.slug,
                type: v.type,
            };
        });

    export type Outbound = {
        owner: string;
        ref: string;
        sha?: string | undefined;
        slug: string;
        type: CreateDeploymentGitSourceDeploymentsRequestType;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Five> = z
        .object({
            owner: z.string(),
            ref: z.string(),
            sha: z.string().optional(),
            slug: z.string(),
            type: CreateDeploymentGitSourceDeploymentsRequestType$,
        })
        .transform((v) => {
            return {
                owner: v.owner,
                ref: v.ref,
                ...(v.sha === undefined ? null : { sha: v.sha }),
                slug: v.slug,
                type: v.type,
            };
        });
}

/** @internal */
export const CreateDeploymentGitSourceDeploymentsType$: z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsType
> = z.nativeEnum(CreateDeploymentGitSourceDeploymentsType);

/** @internal */
export namespace Four$ {
    export const inboundSchema: z.ZodType<Four, z.ZodTypeDef, unknown> = z
        .object({
            ref: z.string(),
            repoUuid: z.string(),
            sha: z.string().optional(),
            type: CreateDeploymentGitSourceDeploymentsType$,
            workspaceUuid: z.string().optional(),
        })
        .transform((v) => {
            return {
                ref: v.ref,
                repoUuid: v.repoUuid,
                ...(v.sha === undefined ? null : { sha: v.sha }),
                type: v.type,
                ...(v.workspaceUuid === undefined ? null : { workspaceUuid: v.workspaceUuid }),
            };
        });

    export type Outbound = {
        ref: string;
        repoUuid: string;
        sha?: string | undefined;
        type: CreateDeploymentGitSourceDeploymentsType;
        workspaceUuid?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Four> = z
        .object({
            ref: z.string(),
            repoUuid: z.string(),
            sha: z.string().optional(),
            type: CreateDeploymentGitSourceDeploymentsType$,
            workspaceUuid: z.string().optional(),
        })
        .transform((v) => {
            return {
                ref: v.ref,
                repoUuid: v.repoUuid,
                ...(v.sha === undefined ? null : { sha: v.sha }),
                type: v.type,
                ...(v.workspaceUuid === undefined ? null : { workspaceUuid: v.workspaceUuid }),
            };
        });
}

/** @internal */
export namespace ProjectId$ {
    export const inboundSchema: z.ZodType<ProjectId, z.ZodTypeDef, unknown> = z.union([
        z.number(),
        z.string(),
    ]);

    export type Outbound = number | string;
    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ProjectId> = z.union([
        z.number(),
        z.string(),
    ]);
}

/** @internal */
export const CreateDeploymentGitSourceType$: z.ZodNativeEnum<typeof CreateDeploymentGitSourceType> =
    z.nativeEnum(CreateDeploymentGitSourceType);

/** @internal */
export namespace Three$ {
    export const inboundSchema: z.ZodType<Three, z.ZodTypeDef, unknown> = z
        .object({
            projectId: z.union([z.number(), z.string()]),
            ref: z.string(),
            sha: z.string().optional(),
            type: CreateDeploymentGitSourceType$,
        })
        .transform((v) => {
            return {
                projectId: v.projectId,
                ref: v.ref,
                ...(v.sha === undefined ? null : { sha: v.sha }),
                type: v.type,
            };
        });

    export type Outbound = {
        projectId: number | string;
        ref: string;
        sha?: string | undefined;
        type: CreateDeploymentGitSourceType;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Three> = z
        .object({
            projectId: z.union([z.number(), z.string()]),
            ref: z.string(),
            sha: z.string().optional(),
            type: CreateDeploymentGitSourceType$,
        })
        .transform((v) => {
            return {
                projectId: v.projectId,
                ref: v.ref,
                ...(v.sha === undefined ? null : { sha: v.sha }),
                type: v.type,
            };
        });
}

/** @internal */
export const GitSourceType$: z.ZodNativeEnum<typeof GitSourceType> = z.nativeEnum(GitSourceType);

/** @internal */
export namespace Two$ {
    export const inboundSchema: z.ZodType<Two, z.ZodTypeDef, unknown> = z
        .object({
            org: z.string(),
            ref: z.string(),
            repo: z.string(),
            sha: z.string().optional(),
            type: GitSourceType$,
        })
        .transform((v) => {
            return {
                org: v.org,
                ref: v.ref,
                repo: v.repo,
                ...(v.sha === undefined ? null : { sha: v.sha }),
                type: v.type,
            };
        });

    export type Outbound = {
        org: string;
        ref: string;
        repo: string;
        sha?: string | undefined;
        type: GitSourceType;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Two> = z
        .object({
            org: z.string(),
            ref: z.string(),
            repo: z.string(),
            sha: z.string().optional(),
            type: GitSourceType$,
        })
        .transform((v) => {
            return {
                org: v.org,
                ref: v.ref,
                repo: v.repo,
                ...(v.sha === undefined ? null : { sha: v.sha }),
                type: v.type,
            };
        });
}

/** @internal */
export namespace RepoId$ {
    export const inboundSchema: z.ZodType<RepoId, z.ZodTypeDef, unknown> = z.union([
        z.number(),
        z.string(),
    ]);

    export type Outbound = number | string;
    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, RepoId> = z.union([
        z.number(),
        z.string(),
    ]);
}

/** @internal */
export const Type$: z.ZodNativeEnum<typeof Type> = z.nativeEnum(Type);

/** @internal */
export namespace One$ {
    export const inboundSchema: z.ZodType<One, z.ZodTypeDef, unknown> = z
        .object({
            ref: z.string(),
            repoId: z.union([z.number(), z.string()]),
            sha: z.string().optional(),
            type: Type$,
        })
        .transform((v) => {
            return {
                ref: v.ref,
                repoId: v.repoId,
                ...(v.sha === undefined ? null : { sha: v.sha }),
                type: v.type,
            };
        });

    export type Outbound = {
        ref: string;
        repoId: number | string;
        sha?: string | undefined;
        type: Type;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, One> = z
        .object({
            ref: z.string(),
            repoId: z.union([z.number(), z.string()]),
            sha: z.string().optional(),
            type: Type$,
        })
        .transform((v) => {
            return {
                ref: v.ref,
                repoId: v.repoId,
                ...(v.sha === undefined ? null : { sha: v.sha }),
                type: v.type,
            };
        });
}

/** @internal */
export namespace GitSource$ {
    export const inboundSchema: z.ZodType<GitSource, z.ZodTypeDef, unknown> = z.union([
        z.lazy(() => One$.inboundSchema),
        z.lazy(() => Three$.inboundSchema),
        z.lazy(() => Two$.inboundSchema),
        z.lazy(() => Four$.inboundSchema),
        z.lazy(() => Five$.inboundSchema),
    ]);

    export type Outbound =
        | One$.Outbound
        | Three$.Outbound
        | Two$.Outbound
        | Four$.Outbound
        | Five$.Outbound;
    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, GitSource> = z.union([
        z.lazy(() => One$.outboundSchema),
        z.lazy(() => Three$.outboundSchema),
        z.lazy(() => Two$.outboundSchema),
        z.lazy(() => Four$.outboundSchema),
        z.lazy(() => Five$.outboundSchema),
    ]);
}

/** @internal */
export const Framework$: z.ZodNativeEnum<typeof Framework> = z.nativeEnum(Framework);

/** @internal */
export const NodeVersion$: z.ZodNativeEnum<typeof NodeVersion> = z.nativeEnum(NodeVersion);

/** @internal */
export namespace ProjectSettings$ {
    export const inboundSchema: z.ZodType<ProjectSettings, z.ZodTypeDef, unknown> = z
        .object({
            buildCommand: z.nullable(z.string()).optional(),
            commandForIgnoringBuildStep: z.nullable(z.string()).optional(),
            devCommand: z.nullable(z.string()).optional(),
            framework: z.nullable(Framework$).optional(),
            installCommand: z.nullable(z.string()).optional(),
            nodeVersion: NodeVersion$.optional(),
            outputDirectory: z.nullable(z.string()).optional(),
            rootDirectory: z.nullable(z.string()).optional(),
            serverlessFunctionRegion: z.nullable(z.string()).optional(),
            skipGitConnectDuringLink: z.boolean().optional(),
            sourceFilesOutsideRootDirectory: z.boolean().optional(),
        })
        .transform((v) => {
            return {
                ...(v.buildCommand === undefined ? null : { buildCommand: v.buildCommand }),
                ...(v.commandForIgnoringBuildStep === undefined
                    ? null
                    : { commandForIgnoringBuildStep: v.commandForIgnoringBuildStep }),
                ...(v.devCommand === undefined ? null : { devCommand: v.devCommand }),
                ...(v.framework === undefined ? null : { framework: v.framework }),
                ...(v.installCommand === undefined ? null : { installCommand: v.installCommand }),
                ...(v.nodeVersion === undefined ? null : { nodeVersion: v.nodeVersion }),
                ...(v.outputDirectory === undefined
                    ? null
                    : { outputDirectory: v.outputDirectory }),
                ...(v.rootDirectory === undefined ? null : { rootDirectory: v.rootDirectory }),
                ...(v.serverlessFunctionRegion === undefined
                    ? null
                    : { serverlessFunctionRegion: v.serverlessFunctionRegion }),
                ...(v.skipGitConnectDuringLink === undefined
                    ? null
                    : { skipGitConnectDuringLink: v.skipGitConnectDuringLink }),
                ...(v.sourceFilesOutsideRootDirectory === undefined
                    ? null
                    : { sourceFilesOutsideRootDirectory: v.sourceFilesOutsideRootDirectory }),
            };
        });

    export type Outbound = {
        buildCommand?: string | null | undefined;
        commandForIgnoringBuildStep?: string | null | undefined;
        devCommand?: string | null | undefined;
        framework?: Framework | null | undefined;
        installCommand?: string | null | undefined;
        nodeVersion?: NodeVersion | undefined;
        outputDirectory?: string | null | undefined;
        rootDirectory?: string | null | undefined;
        serverlessFunctionRegion?: string | null | undefined;
        skipGitConnectDuringLink?: boolean | undefined;
        sourceFilesOutsideRootDirectory?: boolean | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ProjectSettings> = z
        .object({
            buildCommand: z.nullable(z.string()).optional(),
            commandForIgnoringBuildStep: z.nullable(z.string()).optional(),
            devCommand: z.nullable(z.string()).optional(),
            framework: z.nullable(Framework$).optional(),
            installCommand: z.nullable(z.string()).optional(),
            nodeVersion: NodeVersion$.optional(),
            outputDirectory: z.nullable(z.string()).optional(),
            rootDirectory: z.nullable(z.string()).optional(),
            serverlessFunctionRegion: z.nullable(z.string()).optional(),
            skipGitConnectDuringLink: z.boolean().optional(),
            sourceFilesOutsideRootDirectory: z.boolean().optional(),
        })
        .transform((v) => {
            return {
                ...(v.buildCommand === undefined ? null : { buildCommand: v.buildCommand }),
                ...(v.commandForIgnoringBuildStep === undefined
                    ? null
                    : { commandForIgnoringBuildStep: v.commandForIgnoringBuildStep }),
                ...(v.devCommand === undefined ? null : { devCommand: v.devCommand }),
                ...(v.framework === undefined ? null : { framework: v.framework }),
                ...(v.installCommand === undefined ? null : { installCommand: v.installCommand }),
                ...(v.nodeVersion === undefined ? null : { nodeVersion: v.nodeVersion }),
                ...(v.outputDirectory === undefined
                    ? null
                    : { outputDirectory: v.outputDirectory }),
                ...(v.rootDirectory === undefined ? null : { rootDirectory: v.rootDirectory }),
                ...(v.serverlessFunctionRegion === undefined
                    ? null
                    : { serverlessFunctionRegion: v.serverlessFunctionRegion }),
                ...(v.skipGitConnectDuringLink === undefined
                    ? null
                    : { skipGitConnectDuringLink: v.skipGitConnectDuringLink }),
                ...(v.sourceFilesOutsideRootDirectory === undefined
                    ? null
                    : { sourceFilesOutsideRootDirectory: v.sourceFilesOutsideRootDirectory }),
            };
        });
}

/** @internal */
export const Target$: z.ZodNativeEnum<typeof Target> = z.nativeEnum(Target);

/** @internal */
export namespace CreateDeploymentRequestBody$ {
    export const inboundSchema: z.ZodType<CreateDeploymentRequestBody, z.ZodTypeDef, unknown> = z
        .object({
            customEnvironmentSlugOrId: z.string().optional(),
            deploymentId: z.string().optional(),
            files: z
                .array(
                    z.union([
                        z.lazy(() => InlinedFile$.inboundSchema),
                        z.lazy(() => UploadedFile$.inboundSchema),
                    ])
                )
                .optional(),
            gitMetadata: z.lazy(() => GitMetadata$.inboundSchema).optional(),
            gitSource: z
                .union([
                    z.lazy(() => One$.inboundSchema),
                    z.lazy(() => Three$.inboundSchema),
                    z.lazy(() => Two$.inboundSchema),
                    z.lazy(() => Four$.inboundSchema),
                    z.lazy(() => Five$.inboundSchema),
                ])
                .optional(),
            meta: z.record(z.string()).optional(),
            monorepoManager: z.nullable(z.string()).optional(),
            name: z.string(),
            project: z.string().optional(),
            projectSettings: z.lazy(() => ProjectSettings$.inboundSchema).optional(),
            target: Target$.optional(),
            withLatestCommit: z.boolean().optional(),
        })
        .transform((v) => {
            return {
                ...(v.customEnvironmentSlugOrId === undefined
                    ? null
                    : { customEnvironmentSlugOrId: v.customEnvironmentSlugOrId }),
                ...(v.deploymentId === undefined ? null : { deploymentId: v.deploymentId }),
                ...(v.files === undefined ? null : { files: v.files }),
                ...(v.gitMetadata === undefined ? null : { gitMetadata: v.gitMetadata }),
                ...(v.gitSource === undefined ? null : { gitSource: v.gitSource }),
                ...(v.meta === undefined ? null : { meta: v.meta }),
                ...(v.monorepoManager === undefined
                    ? null
                    : { monorepoManager: v.monorepoManager }),
                name: v.name,
                ...(v.project === undefined ? null : { project: v.project }),
                ...(v.projectSettings === undefined
                    ? null
                    : { projectSettings: v.projectSettings }),
                ...(v.target === undefined ? null : { target: v.target }),
                ...(v.withLatestCommit === undefined
                    ? null
                    : { withLatestCommit: v.withLatestCommit }),
            };
        });

    export type Outbound = {
        customEnvironmentSlugOrId?: string | undefined;
        deploymentId?: string | undefined;
        files?: Array<InlinedFile$.Outbound | UploadedFile$.Outbound> | undefined;
        gitMetadata?: GitMetadata$.Outbound | undefined;
        gitSource?:
            | One$.Outbound
            | Three$.Outbound
            | Two$.Outbound
            | Four$.Outbound
            | Five$.Outbound
            | undefined;
        meta?: Record<string, string> | undefined;
        monorepoManager?: string | null | undefined;
        name: string;
        project?: string | undefined;
        projectSettings?: ProjectSettings$.Outbound | undefined;
        target?: Target | undefined;
        withLatestCommit?: boolean | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, CreateDeploymentRequestBody> = z
        .object({
            customEnvironmentSlugOrId: z.string().optional(),
            deploymentId: z.string().optional(),
            files: z
                .array(
                    z.union([
                        z.lazy(() => InlinedFile$.outboundSchema),
                        z.lazy(() => UploadedFile$.outboundSchema),
                    ])
                )
                .optional(),
            gitMetadata: z.lazy(() => GitMetadata$.outboundSchema).optional(),
            gitSource: z
                .union([
                    z.lazy(() => One$.outboundSchema),
                    z.lazy(() => Three$.outboundSchema),
                    z.lazy(() => Two$.outboundSchema),
                    z.lazy(() => Four$.outboundSchema),
                    z.lazy(() => Five$.outboundSchema),
                ])
                .optional(),
            meta: z.record(z.string()).optional(),
            monorepoManager: z.nullable(z.string()).optional(),
            name: z.string(),
            project: z.string().optional(),
            projectSettings: z.lazy(() => ProjectSettings$.outboundSchema).optional(),
            target: Target$.optional(),
            withLatestCommit: z.boolean().optional(),
        })
        .transform((v) => {
            return {
                ...(v.customEnvironmentSlugOrId === undefined
                    ? null
                    : { customEnvironmentSlugOrId: v.customEnvironmentSlugOrId }),
                ...(v.deploymentId === undefined ? null : { deploymentId: v.deploymentId }),
                ...(v.files === undefined ? null : { files: v.files }),
                ...(v.gitMetadata === undefined ? null : { gitMetadata: v.gitMetadata }),
                ...(v.gitSource === undefined ? null : { gitSource: v.gitSource }),
                ...(v.meta === undefined ? null : { meta: v.meta }),
                ...(v.monorepoManager === undefined
                    ? null
                    : { monorepoManager: v.monorepoManager }),
                name: v.name,
                ...(v.project === undefined ? null : { project: v.project }),
                ...(v.projectSettings === undefined
                    ? null
                    : { projectSettings: v.projectSettings }),
                ...(v.target === undefined ? null : { target: v.target }),
                ...(v.withLatestCommit === undefined
                    ? null
                    : { withLatestCommit: v.withLatestCommit }),
            };
        });
}

/** @internal */
export namespace CreateDeploymentRequest$ {
    export const inboundSchema: z.ZodType<CreateDeploymentRequest, z.ZodTypeDef, unknown> = z
        .object({
            forceNew: ForceNew$.optional(),
            skipAutoDetectionConfirmation: SkipAutoDetectionConfirmation$.optional(),
            teamId: z.string().optional(),
            slug: z.string().optional(),
            RequestBody: z.lazy(() => CreateDeploymentRequestBody$.inboundSchema).optional(),
        })
        .transform((v) => {
            return {
                ...(v.forceNew === undefined ? null : { forceNew: v.forceNew }),
                ...(v.skipAutoDetectionConfirmation === undefined
                    ? null
                    : { skipAutoDetectionConfirmation: v.skipAutoDetectionConfirmation }),
                ...(v.teamId === undefined ? null : { teamId: v.teamId }),
                ...(v.slug === undefined ? null : { slug: v.slug }),
                ...(v.RequestBody === undefined ? null : { requestBody: v.RequestBody }),
            };
        });

    export type Outbound = {
        forceNew?: ForceNew | undefined;
        skipAutoDetectionConfirmation?: SkipAutoDetectionConfirmation | undefined;
        teamId?: string | undefined;
        slug?: string | undefined;
        RequestBody?: CreateDeploymentRequestBody$.Outbound | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, CreateDeploymentRequest> = z
        .object({
            forceNew: ForceNew$.optional(),
            skipAutoDetectionConfirmation: SkipAutoDetectionConfirmation$.optional(),
            teamId: z.string().optional(),
            slug: z.string().optional(),
            requestBody: z.lazy(() => CreateDeploymentRequestBody$.outboundSchema).optional(),
        })
        .transform((v) => {
            return {
                ...(v.forceNew === undefined ? null : { forceNew: v.forceNew }),
                ...(v.skipAutoDetectionConfirmation === undefined
                    ? null
                    : { skipAutoDetectionConfirmation: v.skipAutoDetectionConfirmation }),
                ...(v.teamId === undefined ? null : { teamId: v.teamId }),
                ...(v.slug === undefined ? null : { slug: v.slug }),
                ...(v.requestBody === undefined ? null : { RequestBody: v.requestBody }),
            };
        });
}

/** @internal */
export namespace Build$ {
    export const inboundSchema: z.ZodType<Build, z.ZodTypeDef, unknown> = z
        .object({
            env: z.array(z.string()),
        })
        .transform((v) => {
            return {
                env: v.env,
            };
        });

    export type Outbound = {
        env: Array<string>;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Build> = z
        .object({
            env: z.array(z.string()),
        })
        .transform((v) => {
            return {
                env: v.env,
            };
        });
}

/** @internal */
export namespace CreateDeploymentBuilds$ {
    export const inboundSchema: z.ZodType<CreateDeploymentBuilds, z.ZodTypeDef, unknown> = z.object(
        {}
    );

    export type Outbound = {};

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, CreateDeploymentBuilds> =
        z.object({});
}

/** @internal */
export namespace CreateDeploymentCrons$ {
    export const inboundSchema: z.ZodType<CreateDeploymentCrons, z.ZodTypeDef, unknown> = z
        .object({
            schedule: z.string(),
            path: z.string(),
        })
        .transform((v) => {
            return {
                schedule: v.schedule,
                path: v.path,
            };
        });

    export type Outbound = {
        schedule: string;
        path: string;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, CreateDeploymentCrons> = z
        .object({
            schedule: z.string(),
            path: z.string(),
        })
        .transform((v) => {
            return {
                schedule: v.schedule,
                path: v.path,
            };
        });
}

/** @internal */
export namespace Functions$ {
    export const inboundSchema: z.ZodType<Functions, z.ZodTypeDef, unknown> = z
        .object({
            memory: z.number().optional(),
            maxDuration: z.number().optional(),
            runtime: z.string().optional(),
            includeFiles: z.string().optional(),
            excludeFiles: z.string().optional(),
        })
        .transform((v) => {
            return {
                ...(v.memory === undefined ? null : { memory: v.memory }),
                ...(v.maxDuration === undefined ? null : { maxDuration: v.maxDuration }),
                ...(v.runtime === undefined ? null : { runtime: v.runtime }),
                ...(v.includeFiles === undefined ? null : { includeFiles: v.includeFiles }),
                ...(v.excludeFiles === undefined ? null : { excludeFiles: v.excludeFiles }),
            };
        });

    export type Outbound = {
        memory?: number | undefined;
        maxDuration?: number | undefined;
        runtime?: string | undefined;
        includeFiles?: string | undefined;
        excludeFiles?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Functions> = z
        .object({
            memory: z.number().optional(),
            maxDuration: z.number().optional(),
            runtime: z.string().optional(),
            includeFiles: z.string().optional(),
            excludeFiles: z.string().optional(),
        })
        .transform((v) => {
            return {
                ...(v.memory === undefined ? null : { memory: v.memory }),
                ...(v.maxDuration === undefined ? null : { maxDuration: v.maxDuration }),
                ...(v.runtime === undefined ? null : { runtime: v.runtime }),
                ...(v.includeFiles === undefined ? null : { includeFiles: v.includeFiles }),
                ...(v.excludeFiles === undefined ? null : { excludeFiles: v.excludeFiles }),
            };
        });
}

/** @internal */
export const Plan$: z.ZodNativeEnum<typeof Plan> = z.nativeEnum(Plan);

/** @internal */
export namespace Routes3$ {
    export const inboundSchema: z.ZodType<Routes3, z.ZodTypeDef, unknown> = z
        .object({
            src: z.string(),
            continue: z.boolean(),
            middleware: z.number(),
        })
        .transform((v) => {
            return {
                src: v.src,
                continue: v.continue,
                middleware: v.middleware,
            };
        });

    export type Outbound = {
        src: string;
        continue: boolean;
        middleware: number;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Routes3> = z
        .object({
            src: z.string(),
            continue: z.boolean(),
            middleware: z.number(),
        })
        .transform((v) => {
            return {
                src: v.src,
                continue: v.continue,
                middleware: v.middleware,
            };
        });
}

/** @internal */
export const RoutesHandle$: z.ZodNativeEnum<typeof RoutesHandle> = z.nativeEnum(RoutesHandle);

/** @internal */
export namespace Routes2$ {
    export const inboundSchema: z.ZodType<Routes2, z.ZodTypeDef, unknown> = z
        .object({
            handle: RoutesHandle$,
            src: z.string().optional(),
            dest: z.string().optional(),
            status: z.number().optional(),
        })
        .transform((v) => {
            return {
                handle: v.handle,
                ...(v.src === undefined ? null : { src: v.src }),
                ...(v.dest === undefined ? null : { dest: v.dest }),
                ...(v.status === undefined ? null : { status: v.status }),
            };
        });

    export type Outbound = {
        handle: RoutesHandle;
        src?: string | undefined;
        dest?: string | undefined;
        status?: number | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Routes2> = z
        .object({
            handle: RoutesHandle$,
            src: z.string().optional(),
            dest: z.string().optional(),
            status: z.number().optional(),
        })
        .transform((v) => {
            return {
                handle: v.handle,
                ...(v.src === undefined ? null : { src: v.src }),
                ...(v.dest === undefined ? null : { dest: v.dest }),
                ...(v.status === undefined ? null : { status: v.status }),
            };
        });
}

/** @internal */
export const CreateDeploymentHasType$: z.ZodNativeEnum<typeof CreateDeploymentHasType> =
    z.nativeEnum(CreateDeploymentHasType);

/** @internal */
export namespace Has2$ {
    export const inboundSchema: z.ZodType<Has2, z.ZodTypeDef, unknown> = z
        .object({
            type: CreateDeploymentHasType$,
            key: z.string(),
            value: z.string().optional(),
        })
        .transform((v) => {
            return {
                type: v.type,
                key: v.key,
                ...(v.value === undefined ? null : { value: v.value }),
            };
        });

    export type Outbound = {
        type: CreateDeploymentHasType;
        key: string;
        value?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Has2> = z
        .object({
            type: CreateDeploymentHasType$,
            key: z.string(),
            value: z.string().optional(),
        })
        .transform((v) => {
            return {
                type: v.type,
                key: v.key,
                ...(v.value === undefined ? null : { value: v.value }),
            };
        });
}

/** @internal */
export const HasType$: z.ZodNativeEnum<typeof HasType> = z.nativeEnum(HasType);

/** @internal */
export namespace Has1$ {
    export const inboundSchema: z.ZodType<Has1, z.ZodTypeDef, unknown> = z
        .object({
            type: HasType$,
            value: z.string(),
        })
        .transform((v) => {
            return {
                type: v.type,
                value: v.value,
            };
        });

    export type Outbound = {
        type: HasType;
        value: string;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Has1> = z
        .object({
            type: HasType$,
            value: z.string(),
        })
        .transform((v) => {
            return {
                type: v.type,
                value: v.value,
            };
        });
}

/** @internal */
export namespace RoutesHas$ {
    export const inboundSchema: z.ZodType<RoutesHas, z.ZodTypeDef, unknown> = z.union([
        z.lazy(() => Has1$.inboundSchema),
        z.lazy(() => Has2$.inboundSchema),
    ]);

    export type Outbound = Has1$.Outbound | Has2$.Outbound;
    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, RoutesHas> = z.union([
        z.lazy(() => Has1$.outboundSchema),
        z.lazy(() => Has2$.outboundSchema),
    ]);
}

/** @internal */
export const CreateDeploymentMissingType$: z.ZodNativeEnum<typeof CreateDeploymentMissingType> =
    z.nativeEnum(CreateDeploymentMissingType);

/** @internal */
export namespace Missing2$ {
    export const inboundSchema: z.ZodType<Missing2, z.ZodTypeDef, unknown> = z
        .object({
            type: CreateDeploymentMissingType$,
            key: z.string(),
            value: z.string().optional(),
        })
        .transform((v) => {
            return {
                type: v.type,
                key: v.key,
                ...(v.value === undefined ? null : { value: v.value }),
            };
        });

    export type Outbound = {
        type: CreateDeploymentMissingType;
        key: string;
        value?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Missing2> = z
        .object({
            type: CreateDeploymentMissingType$,
            key: z.string(),
            value: z.string().optional(),
        })
        .transform((v) => {
            return {
                type: v.type,
                key: v.key,
                ...(v.value === undefined ? null : { value: v.value }),
            };
        });
}

/** @internal */
export const MissingType$: z.ZodNativeEnum<typeof MissingType> = z.nativeEnum(MissingType);

/** @internal */
export namespace Missing1$ {
    export const inboundSchema: z.ZodType<Missing1, z.ZodTypeDef, unknown> = z
        .object({
            type: MissingType$,
            value: z.string(),
        })
        .transform((v) => {
            return {
                type: v.type,
                value: v.value,
            };
        });

    export type Outbound = {
        type: MissingType;
        value: string;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Missing1> = z
        .object({
            type: MissingType$,
            value: z.string(),
        })
        .transform((v) => {
            return {
                type: v.type,
                value: v.value,
            };
        });
}

/** @internal */
export namespace RoutesMissing$ {
    export const inboundSchema: z.ZodType<RoutesMissing, z.ZodTypeDef, unknown> = z.union([
        z.lazy(() => Missing1$.inboundSchema),
        z.lazy(() => Missing2$.inboundSchema),
    ]);

    export type Outbound = Missing1$.Outbound | Missing2$.Outbound;
    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, RoutesMissing> = z.union([
        z.lazy(() => Missing1$.outboundSchema),
        z.lazy(() => Missing2$.outboundSchema),
    ]);
}

/** @internal */
export namespace Locale$ {
    export const inboundSchema: z.ZodType<Locale, z.ZodTypeDef, unknown> = z
        .object({
            redirect: z.record(z.string()).optional(),
            cookie: z.string().optional(),
        })
        .transform((v) => {
            return {
                ...(v.redirect === undefined ? null : { redirect: v.redirect }),
                ...(v.cookie === undefined ? null : { cookie: v.cookie }),
            };
        });

    export type Outbound = {
        redirect?: Record<string, string> | undefined;
        cookie?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Locale> = z
        .object({
            redirect: z.record(z.string()).optional(),
            cookie: z.string().optional(),
        })
        .transform((v) => {
            return {
                ...(v.redirect === undefined ? null : { redirect: v.redirect }),
                ...(v.cookie === undefined ? null : { cookie: v.cookie }),
            };
        });
}

/** @internal */
export namespace Routes1$ {
    export const inboundSchema: z.ZodType<Routes1, z.ZodTypeDef, unknown> = z
        .object({
            src: z.string(),
            dest: z.string().optional(),
            headers: z.record(z.string()).optional(),
            methods: z.array(z.string()).optional(),
            continue: z.boolean().optional(),
            override: z.boolean().optional(),
            caseSensitive: z.boolean().optional(),
            check: z.boolean().optional(),
            important: z.boolean().optional(),
            status: z.number().optional(),
            has: z
                .array(
                    z.union([z.lazy(() => Has1$.inboundSchema), z.lazy(() => Has2$.inboundSchema)])
                )
                .optional(),
            missing: z
                .array(
                    z.union([
                        z.lazy(() => Missing1$.inboundSchema),
                        z.lazy(() => Missing2$.inboundSchema),
                    ])
                )
                .optional(),
            locale: z.lazy(() => Locale$.inboundSchema).optional(),
            middlewarePath: z.string().optional(),
            middlewareRawSrc: z.array(z.string()).optional(),
            middleware: z.number().optional(),
        })
        .transform((v) => {
            return {
                src: v.src,
                ...(v.dest === undefined ? null : { dest: v.dest }),
                ...(v.headers === undefined ? null : { headers: v.headers }),
                ...(v.methods === undefined ? null : { methods: v.methods }),
                ...(v.continue === undefined ? null : { continue: v.continue }),
                ...(v.override === undefined ? null : { override: v.override }),
                ...(v.caseSensitive === undefined ? null : { caseSensitive: v.caseSensitive }),
                ...(v.check === undefined ? null : { check: v.check }),
                ...(v.important === undefined ? null : { important: v.important }),
                ...(v.status === undefined ? null : { status: v.status }),
                ...(v.has === undefined ? null : { has: v.has }),
                ...(v.missing === undefined ? null : { missing: v.missing }),
                ...(v.locale === undefined ? null : { locale: v.locale }),
                ...(v.middlewarePath === undefined ? null : { middlewarePath: v.middlewarePath }),
                ...(v.middlewareRawSrc === undefined
                    ? null
                    : { middlewareRawSrc: v.middlewareRawSrc }),
                ...(v.middleware === undefined ? null : { middleware: v.middleware }),
            };
        });

    export type Outbound = {
        src: string;
        dest?: string | undefined;
        headers?: Record<string, string> | undefined;
        methods?: Array<string> | undefined;
        continue?: boolean | undefined;
        override?: boolean | undefined;
        caseSensitive?: boolean | undefined;
        check?: boolean | undefined;
        important?: boolean | undefined;
        status?: number | undefined;
        has?: Array<Has1$.Outbound | Has2$.Outbound> | undefined;
        missing?: Array<Missing1$.Outbound | Missing2$.Outbound> | undefined;
        locale?: Locale$.Outbound | undefined;
        middlewarePath?: string | undefined;
        middlewareRawSrc?: Array<string> | undefined;
        middleware?: number | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Routes1> = z
        .object({
            src: z.string(),
            dest: z.string().optional(),
            headers: z.record(z.string()).optional(),
            methods: z.array(z.string()).optional(),
            continue: z.boolean().optional(),
            override: z.boolean().optional(),
            caseSensitive: z.boolean().optional(),
            check: z.boolean().optional(),
            important: z.boolean().optional(),
            status: z.number().optional(),
            has: z
                .array(
                    z.union([
                        z.lazy(() => Has1$.outboundSchema),
                        z.lazy(() => Has2$.outboundSchema),
                    ])
                )
                .optional(),
            missing: z
                .array(
                    z.union([
                        z.lazy(() => Missing1$.outboundSchema),
                        z.lazy(() => Missing2$.outboundSchema),
                    ])
                )
                .optional(),
            locale: z.lazy(() => Locale$.outboundSchema).optional(),
            middlewarePath: z.string().optional(),
            middlewareRawSrc: z.array(z.string()).optional(),
            middleware: z.number().optional(),
        })
        .transform((v) => {
            return {
                src: v.src,
                ...(v.dest === undefined ? null : { dest: v.dest }),
                ...(v.headers === undefined ? null : { headers: v.headers }),
                ...(v.methods === undefined ? null : { methods: v.methods }),
                ...(v.continue === undefined ? null : { continue: v.continue }),
                ...(v.override === undefined ? null : { override: v.override }),
                ...(v.caseSensitive === undefined ? null : { caseSensitive: v.caseSensitive }),
                ...(v.check === undefined ? null : { check: v.check }),
                ...(v.important === undefined ? null : { important: v.important }),
                ...(v.status === undefined ? null : { status: v.status }),
                ...(v.has === undefined ? null : { has: v.has }),
                ...(v.missing === undefined ? null : { missing: v.missing }),
                ...(v.locale === undefined ? null : { locale: v.locale }),
                ...(v.middlewarePath === undefined ? null : { middlewarePath: v.middlewarePath }),
                ...(v.middlewareRawSrc === undefined
                    ? null
                    : { middlewareRawSrc: v.middlewareRawSrc }),
                ...(v.middleware === undefined ? null : { middleware: v.middleware }),
            };
        });
}

/** @internal */
export namespace Routes$ {
    export const inboundSchema: z.ZodType<Routes, z.ZodTypeDef, unknown> = z.union([
        z.lazy(() => Routes3$.inboundSchema),
        z.lazy(() => Routes2$.inboundSchema),
        z.lazy(() => Routes1$.inboundSchema),
    ]);

    export type Outbound = Routes3$.Outbound | Routes2$.Outbound | Routes1$.Outbound;
    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Routes> = z.union([
        z.lazy(() => Routes3$.outboundSchema),
        z.lazy(() => Routes2$.outboundSchema),
        z.lazy(() => Routes1$.outboundSchema),
    ]);
}

/** @internal */
export const CreateDeploymentGitRepoDeploymentsType$: z.ZodNativeEnum<
    typeof CreateDeploymentGitRepoDeploymentsType
> = z.nativeEnum(CreateDeploymentGitRepoDeploymentsType);

/** @internal */
export const CreateDeploymentGitRepoOwnerType$: z.ZodNativeEnum<
    typeof CreateDeploymentGitRepoOwnerType
> = z.nativeEnum(CreateDeploymentGitRepoOwnerType);

/** @internal */
export namespace GitRepo3$ {
    export const inboundSchema: z.ZodType<GitRepo3, z.ZodTypeDef, unknown> = z
        .object({
            owner: z.string(),
            repoUuid: z.string(),
            slug: z.string(),
            type: CreateDeploymentGitRepoDeploymentsType$,
            workspaceUuid: z.string(),
            path: z.string(),
            defaultBranch: z.string(),
            name: z.string(),
            private: z.boolean(),
            ownerType: CreateDeploymentGitRepoOwnerType$,
        })
        .transform((v) => {
            return {
                owner: v.owner,
                repoUuid: v.repoUuid,
                slug: v.slug,
                type: v.type,
                workspaceUuid: v.workspaceUuid,
                path: v.path,
                defaultBranch: v.defaultBranch,
                name: v.name,
                private: v.private,
                ownerType: v.ownerType,
            };
        });

    export type Outbound = {
        owner: string;
        repoUuid: string;
        slug: string;
        type: CreateDeploymentGitRepoDeploymentsType;
        workspaceUuid: string;
        path: string;
        defaultBranch: string;
        name: string;
        private: boolean;
        ownerType: CreateDeploymentGitRepoOwnerType;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, GitRepo3> = z
        .object({
            owner: z.string(),
            repoUuid: z.string(),
            slug: z.string(),
            type: CreateDeploymentGitRepoDeploymentsType$,
            workspaceUuid: z.string(),
            path: z.string(),
            defaultBranch: z.string(),
            name: z.string(),
            private: z.boolean(),
            ownerType: CreateDeploymentGitRepoOwnerType$,
        })
        .transform((v) => {
            return {
                owner: v.owner,
                repoUuid: v.repoUuid,
                slug: v.slug,
                type: v.type,
                workspaceUuid: v.workspaceUuid,
                path: v.path,
                defaultBranch: v.defaultBranch,
                name: v.name,
                private: v.private,
                ownerType: v.ownerType,
            };
        });
}

/** @internal */
export const CreateDeploymentGitRepoType$: z.ZodNativeEnum<typeof CreateDeploymentGitRepoType> =
    z.nativeEnum(CreateDeploymentGitRepoType);

/** @internal */
export const GitRepoOwnerType$: z.ZodNativeEnum<typeof GitRepoOwnerType> =
    z.nativeEnum(GitRepoOwnerType);

/** @internal */
export namespace GitRepo2$ {
    export const inboundSchema: z.ZodType<GitRepo2, z.ZodTypeDef, unknown> = z
        .object({
            org: z.string(),
            repo: z.string(),
            repoId: z.number(),
            type: CreateDeploymentGitRepoType$,
            repoOwnerId: z.string(),
            path: z.string(),
            defaultBranch: z.string(),
            name: z.string(),
            private: z.boolean(),
            ownerType: GitRepoOwnerType$,
        })
        .transform((v) => {
            return {
                org: v.org,
                repo: v.repo,
                repoId: v.repoId,
                type: v.type,
                repoOwnerId: v.repoOwnerId,
                path: v.path,
                defaultBranch: v.defaultBranch,
                name: v.name,
                private: v.private,
                ownerType: v.ownerType,
            };
        });

    export type Outbound = {
        org: string;
        repo: string;
        repoId: number;
        type: CreateDeploymentGitRepoType;
        repoOwnerId: string;
        path: string;
        defaultBranch: string;
        name: string;
        private: boolean;
        ownerType: GitRepoOwnerType;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, GitRepo2> = z
        .object({
            org: z.string(),
            repo: z.string(),
            repoId: z.number(),
            type: CreateDeploymentGitRepoType$,
            repoOwnerId: z.string(),
            path: z.string(),
            defaultBranch: z.string(),
            name: z.string(),
            private: z.boolean(),
            ownerType: GitRepoOwnerType$,
        })
        .transform((v) => {
            return {
                org: v.org,
                repo: v.repo,
                repoId: v.repoId,
                type: v.type,
                repoOwnerId: v.repoOwnerId,
                path: v.path,
                defaultBranch: v.defaultBranch,
                name: v.name,
                private: v.private,
                ownerType: v.ownerType,
            };
        });
}

/** @internal */
export const GitRepoType$: z.ZodNativeEnum<typeof GitRepoType> = z.nativeEnum(GitRepoType);

/** @internal */
export const CreateDeploymentGitRepoDeploymentsOwnerType$: z.ZodNativeEnum<
    typeof CreateDeploymentGitRepoDeploymentsOwnerType
> = z.nativeEnum(CreateDeploymentGitRepoDeploymentsOwnerType);

/** @internal */
export namespace GitRepo1$ {
    export const inboundSchema: z.ZodType<GitRepo1, z.ZodTypeDef, unknown> = z
        .object({
            namespace: z.string(),
            projectId: z.number(),
            type: GitRepoType$,
            url: z.string(),
            path: z.string(),
            defaultBranch: z.string(),
            name: z.string(),
            private: z.boolean(),
            ownerType: CreateDeploymentGitRepoDeploymentsOwnerType$,
        })
        .transform((v) => {
            return {
                namespace: v.namespace,
                projectId: v.projectId,
                type: v.type,
                url: v.url,
                path: v.path,
                defaultBranch: v.defaultBranch,
                name: v.name,
                private: v.private,
                ownerType: v.ownerType,
            };
        });

    export type Outbound = {
        namespace: string;
        projectId: number;
        type: GitRepoType;
        url: string;
        path: string;
        defaultBranch: string;
        name: string;
        private: boolean;
        ownerType: CreateDeploymentGitRepoDeploymentsOwnerType;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, GitRepo1> = z
        .object({
            namespace: z.string(),
            projectId: z.number(),
            type: GitRepoType$,
            url: z.string(),
            path: z.string(),
            defaultBranch: z.string(),
            name: z.string(),
            private: z.boolean(),
            ownerType: CreateDeploymentGitRepoDeploymentsOwnerType$,
        })
        .transform((v) => {
            return {
                namespace: v.namespace,
                projectId: v.projectId,
                type: v.type,
                url: v.url,
                path: v.path,
                defaultBranch: v.defaultBranch,
                name: v.name,
                private: v.private,
                ownerType: v.ownerType,
            };
        });
}

/** @internal */
export namespace GitRepo$ {
    export const inboundSchema: z.ZodType<GitRepo, z.ZodTypeDef, unknown> = z.union([
        z.lazy(() => GitRepo1$.inboundSchema),
        z.lazy(() => GitRepo2$.inboundSchema),
        z.lazy(() => GitRepo3$.inboundSchema),
    ]);

    export type Outbound = GitRepo1$.Outbound | GitRepo2$.Outbound | GitRepo3$.Outbound;
    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, GitRepo> = z.union([
        z.lazy(() => GitRepo1$.outboundSchema),
        z.lazy(() => GitRepo2$.outboundSchema),
        z.lazy(() => GitRepo3$.outboundSchema),
    ]);
}

/** @internal */
export namespace AliasAssignedAt$ {
    export const inboundSchema: z.ZodType<AliasAssignedAt, z.ZodTypeDef, unknown> = z.union([
        z.number(),
        z.boolean(),
    ]);

    export type Outbound = number | boolean;
    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, AliasAssignedAt> = z.union([
        z.number(),
        z.boolean(),
    ]);
}

/** @internal */
export const CreateDeploymentDeploymentsReadyState$: z.ZodNativeEnum<
    typeof CreateDeploymentDeploymentsReadyState
> = z.nativeEnum(CreateDeploymentDeploymentsReadyState);

/** @internal */
export namespace CreateDeploymentOutput$ {
    export const inboundSchema: z.ZodType<CreateDeploymentOutput, z.ZodTypeDef, unknown> = z
        .object({
            path: z.string(),
            functionName: z.string(),
        })
        .transform((v) => {
            return {
                path: v.path,
                functionName: v.functionName,
            };
        });

    export type Outbound = {
        path: string;
        functionName: string;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, CreateDeploymentOutput> = z
        .object({
            path: z.string(),
            functionName: z.string(),
        })
        .transform((v) => {
            return {
                path: v.path,
                functionName: v.functionName,
            };
        });
}

/** @internal */
export namespace Lambdas$ {
    export const inboundSchema: z.ZodType<Lambdas, z.ZodTypeDef, unknown> = z
        .object({
            id: z.string(),
            createdAt: z.number().optional(),
            entrypoint: z.nullable(z.string()).optional(),
            readyState: CreateDeploymentDeploymentsReadyState$.optional(),
            readyStateAt: z.number().optional(),
            output: z.array(z.lazy(() => CreateDeploymentOutput$.inboundSchema)),
        })
        .transform((v) => {
            return {
                id: v.id,
                ...(v.createdAt === undefined ? null : { createdAt: v.createdAt }),
                ...(v.entrypoint === undefined ? null : { entrypoint: v.entrypoint }),
                ...(v.readyState === undefined ? null : { readyState: v.readyState }),
                ...(v.readyStateAt === undefined ? null : { readyStateAt: v.readyStateAt }),
                output: v.output,
            };
        });

    export type Outbound = {
        id: string;
        createdAt?: number | undefined;
        entrypoint?: string | null | undefined;
        readyState?: CreateDeploymentDeploymentsReadyState | undefined;
        readyStateAt?: number | undefined;
        output: Array<CreateDeploymentOutput$.Outbound>;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Lambdas> = z
        .object({
            id: z.string(),
            createdAt: z.number().optional(),
            entrypoint: z.nullable(z.string()).optional(),
            readyState: CreateDeploymentDeploymentsReadyState$.optional(),
            readyStateAt: z.number().optional(),
            output: z.array(z.lazy(() => CreateDeploymentOutput$.outboundSchema)),
        })
        .transform((v) => {
            return {
                id: v.id,
                ...(v.createdAt === undefined ? null : { createdAt: v.createdAt }),
                ...(v.entrypoint === undefined ? null : { entrypoint: v.entrypoint }),
                ...(v.readyState === undefined ? null : { readyState: v.readyState }),
                ...(v.readyStateAt === undefined ? null : { readyStateAt: v.readyStateAt }),
                output: v.output,
            };
        });
}

/** @internal */
export namespace Project$ {
    export const inboundSchema: z.ZodType<Project, z.ZodTypeDef, unknown> = z
        .object({
            id: z.string(),
            name: z.string(),
            framework: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return {
                id: v.id,
                name: v.name,
                ...(v.framework === undefined ? null : { framework: v.framework }),
            };
        });

    export type Outbound = {
        id: string;
        name: string;
        framework?: string | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Project> = z
        .object({
            id: z.string(),
            name: z.string(),
            framework: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return {
                id: v.id,
                name: v.name,
                ...(v.framework === undefined ? null : { framework: v.framework }),
            };
        });
}

/** @internal */
export const CreateDeploymentReadyState$: z.ZodNativeEnum<typeof CreateDeploymentReadyState> =
    z.nativeEnum(CreateDeploymentReadyState);

/** @internal */
export const ReadySubstate$: z.ZodNativeEnum<typeof ReadySubstate> = z.nativeEnum(ReadySubstate);

/** @internal */
export const CreateDeploymentSource$: z.ZodNativeEnum<typeof CreateDeploymentSource> =
    z.nativeEnum(CreateDeploymentSource);

/** @internal */
export const CreateDeploymentTarget$: z.ZodNativeEnum<typeof CreateDeploymentTarget> =
    z.nativeEnum(CreateDeploymentTarget);

/** @internal */
export namespace Team$ {
    export const inboundSchema: z.ZodType<Team, z.ZodTypeDef, unknown> = z
        .object({
            id: z.string(),
            name: z.string(),
            slug: z.string(),
            avatar: z.string().optional(),
        })
        .transform((v) => {
            return {
                id: v.id,
                name: v.name,
                slug: v.slug,
                ...(v.avatar === undefined ? null : { avatar: v.avatar }),
            };
        });

    export type Outbound = {
        id: string;
        name: string;
        slug: string;
        avatar?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Team> = z
        .object({
            id: z.string(),
            name: z.string(),
            slug: z.string(),
            avatar: z.string().optional(),
        })
        .transform((v) => {
            return {
                id: v.id,
                name: v.name,
                slug: v.slug,
                ...(v.avatar === undefined ? null : { avatar: v.avatar }),
            };
        });
}

/** @internal */
export const CreateDeploymentType$: z.ZodNativeEnum<typeof CreateDeploymentType> =
    z.nativeEnum(CreateDeploymentType);

/** @internal */
export namespace AliasError$ {
    export const inboundSchema: z.ZodType<AliasError, z.ZodTypeDef, unknown> = z
        .object({
            code: z.string(),
            message: z.string(),
        })
        .transform((v) => {
            return {
                code: v.code,
                message: v.message,
            };
        });

    export type Outbound = {
        code: string;
        message: string;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, AliasError> = z
        .object({
            code: z.string(),
            message: z.string(),
        })
        .transform((v) => {
            return {
                code: v.code,
                message: v.message,
            };
        });
}

/** @internal */
export namespace AliasWarning$ {
    export const inboundSchema: z.ZodType<AliasWarning, z.ZodTypeDef, unknown> = z
        .object({
            code: z.string(),
            message: z.string(),
            link: z.string().optional(),
            action: z.string().optional(),
        })
        .transform((v) => {
            return {
                code: v.code,
                message: v.message,
                ...(v.link === undefined ? null : { link: v.link }),
                ...(v.action === undefined ? null : { action: v.action }),
            };
        });

    export type Outbound = {
        code: string;
        message: string;
        link?: string | undefined;
        action?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, AliasWarning> = z
        .object({
            code: z.string(),
            message: z.string(),
            link: z.string().optional(),
            action: z.string().optional(),
        })
        .transform((v) => {
            return {
                code: v.code,
                message: v.message,
                ...(v.link === undefined ? null : { link: v.link }),
                ...(v.action === undefined ? null : { action: v.action }),
            };
        });
}

/** @internal */
export const ChecksState$: z.ZodNativeEnum<typeof ChecksState> = z.nativeEnum(ChecksState);

/** @internal */
export const ChecksConclusion$: z.ZodNativeEnum<typeof ChecksConclusion> =
    z.nativeEnum(ChecksConclusion);

/** @internal */
export namespace Creator$ {
    export const inboundSchema: z.ZodType<Creator, z.ZodTypeDef, unknown> = z
        .object({
            uid: z.string(),
            username: z.string().optional(),
            avatar: z.string().optional(),
        })
        .transform((v) => {
            return {
                uid: v.uid,
                ...(v.username === undefined ? null : { username: v.username }),
                ...(v.avatar === undefined ? null : { avatar: v.avatar }),
            };
        });

    export type Outbound = {
        uid: string;
        username?: string | undefined;
        avatar?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Creator> = z
        .object({
            uid: z.string(),
            username: z.string().optional(),
            avatar: z.string().optional(),
        })
        .transform((v) => {
            return {
                uid: v.uid,
                ...(v.username === undefined ? null : { username: v.username }),
                ...(v.avatar === undefined ? null : { avatar: v.avatar }),
            };
        });
}

/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type$: z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type
> = z.nativeEnum(CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type);

/** @internal */
export namespace CreateDeploymentGitSource9$ {
    export const inboundSchema: z.ZodType<CreateDeploymentGitSource9, z.ZodTypeDef, unknown> = z
        .object({
            type: CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type$,
            ref: z.string(),
            sha: z.string(),
            owner: z.string().optional(),
            slug: z.string().optional(),
            workspaceUuid: z.string(),
            repoUuid: z.string(),
        })
        .transform((v) => {
            return {
                type: v.type,
                ref: v.ref,
                sha: v.sha,
                ...(v.owner === undefined ? null : { owner: v.owner }),
                ...(v.slug === undefined ? null : { slug: v.slug }),
                workspaceUuid: v.workspaceUuid,
                repoUuid: v.repoUuid,
            };
        });

    export type Outbound = {
        type: CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type;
        ref: string;
        sha: string;
        owner?: string | undefined;
        slug?: string | undefined;
        workspaceUuid: string;
        repoUuid: string;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, CreateDeploymentGitSource9> = z
        .object({
            type: CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type$,
            ref: z.string(),
            sha: z.string(),
            owner: z.string().optional(),
            slug: z.string().optional(),
            workspaceUuid: z.string(),
            repoUuid: z.string(),
        })
        .transform((v) => {
            return {
                type: v.type,
                ref: v.ref,
                sha: v.sha,
                ...(v.owner === undefined ? null : { owner: v.owner }),
                ...(v.slug === undefined ? null : { slug: v.slug }),
                workspaceUuid: v.workspaceUuid,
                repoUuid: v.repoUuid,
            };
        });
}

/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type$: z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type
> = z.nativeEnum(CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type);

/** @internal */
export namespace CreateDeploymentGitSource8$ {
    export const inboundSchema: z.ZodType<CreateDeploymentGitSource8, z.ZodTypeDef, unknown> = z
        .object({
            type: CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type$,
            ref: z.string(),
            sha: z.string(),
            projectId: z.number(),
        })
        .transform((v) => {
            return {
                type: v.type,
                ref: v.ref,
                sha: v.sha,
                projectId: v.projectId,
            };
        });

    export type Outbound = {
        type: CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type;
        ref: string;
        sha: string;
        projectId: number;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, CreateDeploymentGitSource8> = z
        .object({
            type: CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type$,
            ref: z.string(),
            sha: z.string(),
            projectId: z.number(),
        })
        .transform((v) => {
            return {
                type: v.type,
                ref: v.ref,
                sha: v.sha,
                projectId: v.projectId,
            };
        });
}

/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type$: z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type
> = z.nativeEnum(CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type);

/** @internal */
export namespace CreateDeploymentGitSource7$ {
    export const inboundSchema: z.ZodType<CreateDeploymentGitSource7, z.ZodTypeDef, unknown> = z
        .object({
            type: CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type$,
            ref: z.string(),
            sha: z.string(),
            repoId: z.number(),
            org: z.string().optional(),
            repo: z.string().optional(),
        })
        .transform((v) => {
            return {
                type: v.type,
                ref: v.ref,
                sha: v.sha,
                repoId: v.repoId,
                ...(v.org === undefined ? null : { org: v.org }),
                ...(v.repo === undefined ? null : { repo: v.repo }),
            };
        });

    export type Outbound = {
        type: CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type;
        ref: string;
        sha: string;
        repoId: number;
        org?: string | undefined;
        repo?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, CreateDeploymentGitSource7> = z
        .object({
            type: CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type$,
            ref: z.string(),
            sha: z.string(),
            repoId: z.number(),
            org: z.string().optional(),
            repo: z.string().optional(),
        })
        .transform((v) => {
            return {
                type: v.type,
                ref: v.ref,
                sha: v.sha,
                repoId: v.repoId,
                ...(v.org === undefined ? null : { org: v.org }),
                ...(v.repo === undefined ? null : { repo: v.repo }),
            };
        });
}

/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type$: z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type
> = z.nativeEnum(CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type);

/** @internal */
export namespace CreateDeploymentGitSource6$ {
    export const inboundSchema: z.ZodType<CreateDeploymentGitSource6, z.ZodTypeDef, unknown> = z
        .object({
            type: CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type$,
            ref: z.string(),
            sha: z.string(),
            gitUrl: z.string(),
        })
        .transform((v) => {
            return {
                type: v.type,
                ref: v.ref,
                sha: v.sha,
                gitUrl: v.gitUrl,
            };
        });

    export type Outbound = {
        type: CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type;
        ref: string;
        sha: string;
        gitUrl: string;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, CreateDeploymentGitSource6> = z
        .object({
            type: CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type$,
            ref: z.string(),
            sha: z.string(),
            gitUrl: z.string(),
        })
        .transform((v) => {
            return {
                type: v.type,
                ref: v.ref,
                sha: v.sha,
                gitUrl: v.gitUrl,
            };
        });
}

/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type$: z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type
> = z.nativeEnum(CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type);

/** @internal */
export namespace GitSource5$ {
    export const inboundSchema: z.ZodType<GitSource5, z.ZodTypeDef, unknown> = z
        .object({
            type: CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type$,
            owner: z.string(),
            slug: z.string(),
            ref: z.nullable(z.string()).optional(),
            sha: z.string().optional(),
            prId: z.nullable(z.number()).optional(),
        })
        .transform((v) => {
            return {
                type: v.type,
                owner: v.owner,
                slug: v.slug,
                ...(v.ref === undefined ? null : { ref: v.ref }),
                ...(v.sha === undefined ? null : { sha: v.sha }),
                ...(v.prId === undefined ? null : { prId: v.prId }),
            };
        });

    export type Outbound = {
        type: CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type;
        owner: string;
        slug: string;
        ref?: string | null | undefined;
        sha?: string | undefined;
        prId?: number | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, GitSource5> = z
        .object({
            type: CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type$,
            owner: z.string(),
            slug: z.string(),
            ref: z.nullable(z.string()).optional(),
            sha: z.string().optional(),
            prId: z.nullable(z.number()).optional(),
        })
        .transform((v) => {
            return {
                type: v.type,
                owner: v.owner,
                slug: v.slug,
                ...(v.ref === undefined ? null : { ref: v.ref }),
                ...(v.sha === undefined ? null : { sha: v.sha }),
                ...(v.prId === undefined ? null : { prId: v.prId }),
            };
        });
}

/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType$: z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType
> = z.nativeEnum(CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType);

/** @internal */
export namespace GitSource4$ {
    export const inboundSchema: z.ZodType<GitSource4, z.ZodTypeDef, unknown> = z
        .object({
            type: CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType$,
            workspaceUuid: z.string().optional(),
            repoUuid: z.string(),
            ref: z.nullable(z.string()).optional(),
            sha: z.string().optional(),
            prId: z.nullable(z.number()).optional(),
        })
        .transform((v) => {
            return {
                type: v.type,
                ...(v.workspaceUuid === undefined ? null : { workspaceUuid: v.workspaceUuid }),
                repoUuid: v.repoUuid,
                ...(v.ref === undefined ? null : { ref: v.ref }),
                ...(v.sha === undefined ? null : { sha: v.sha }),
                ...(v.prId === undefined ? null : { prId: v.prId }),
            };
        });

    export type Outbound = {
        type: CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType;
        workspaceUuid?: string | undefined;
        repoUuid: string;
        ref?: string | null | undefined;
        sha?: string | undefined;
        prId?: number | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, GitSource4> = z
        .object({
            type: CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType$,
            workspaceUuid: z.string().optional(),
            repoUuid: z.string(),
            ref: z.nullable(z.string()).optional(),
            sha: z.string().optional(),
            prId: z.nullable(z.number()).optional(),
        })
        .transform((v) => {
            return {
                type: v.type,
                ...(v.workspaceUuid === undefined ? null : { workspaceUuid: v.workspaceUuid }),
                repoUuid: v.repoUuid,
                ...(v.ref === undefined ? null : { ref: v.ref }),
                ...(v.sha === undefined ? null : { sha: v.sha }),
                ...(v.prId === undefined ? null : { prId: v.prId }),
            };
        });
}

/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType$: z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType
> = z.nativeEnum(CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType);

/** @internal */
export namespace GitSourceProjectId$ {
    export const inboundSchema: z.ZodType<GitSourceProjectId, z.ZodTypeDef, unknown> = z.union([
        z.string(),
        z.number(),
    ]);

    export type Outbound = string | number;
    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, GitSourceProjectId> = z.union([
        z.string(),
        z.number(),
    ]);
}

/** @internal */
export namespace GitSource3$ {
    export const inboundSchema: z.ZodType<GitSource3, z.ZodTypeDef, unknown> = z
        .object({
            type: CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType$,
            projectId: z.union([z.string(), z.number()]),
            ref: z.nullable(z.string()).optional(),
            sha: z.string().optional(),
            prId: z.nullable(z.number()).optional(),
        })
        .transform((v) => {
            return {
                type: v.type,
                projectId: v.projectId,
                ...(v.ref === undefined ? null : { ref: v.ref }),
                ...(v.sha === undefined ? null : { sha: v.sha }),
                ...(v.prId === undefined ? null : { prId: v.prId }),
            };
        });

    export type Outbound = {
        type: CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType;
        projectId: string | number;
        ref?: string | null | undefined;
        sha?: string | undefined;
        prId?: number | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, GitSource3> = z
        .object({
            type: CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType$,
            projectId: z.union([z.string(), z.number()]),
            ref: z.nullable(z.string()).optional(),
            sha: z.string().optional(),
            prId: z.nullable(z.number()).optional(),
        })
        .transform((v) => {
            return {
                type: v.type,
                projectId: v.projectId,
                ...(v.ref === undefined ? null : { ref: v.ref }),
                ...(v.sha === undefined ? null : { sha: v.sha }),
                ...(v.prId === undefined ? null : { prId: v.prId }),
            };
        });
}

/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponse200Type$: z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200Type
> = z.nativeEnum(CreateDeploymentGitSourceDeploymentsResponse200Type);

/** @internal */
export namespace GitSource2$ {
    export const inboundSchema: z.ZodType<GitSource2, z.ZodTypeDef, unknown> = z
        .object({
            type: CreateDeploymentGitSourceDeploymentsResponse200Type$,
            org: z.string(),
            repo: z.string(),
            ref: z.nullable(z.string()).optional(),
            sha: z.string().optional(),
            prId: z.nullable(z.number()).optional(),
        })
        .transform((v) => {
            return {
                type: v.type,
                org: v.org,
                repo: v.repo,
                ...(v.ref === undefined ? null : { ref: v.ref }),
                ...(v.sha === undefined ? null : { sha: v.sha }),
                ...(v.prId === undefined ? null : { prId: v.prId }),
            };
        });

    export type Outbound = {
        type: CreateDeploymentGitSourceDeploymentsResponse200Type;
        org: string;
        repo: string;
        ref?: string | null | undefined;
        sha?: string | undefined;
        prId?: number | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, GitSource2> = z
        .object({
            type: CreateDeploymentGitSourceDeploymentsResponse200Type$,
            org: z.string(),
            repo: z.string(),
            ref: z.nullable(z.string()).optional(),
            sha: z.string().optional(),
            prId: z.nullable(z.number()).optional(),
        })
        .transform((v) => {
            return {
                type: v.type,
                org: v.org,
                repo: v.repo,
                ...(v.ref === undefined ? null : { ref: v.ref }),
                ...(v.sha === undefined ? null : { sha: v.sha }),
                ...(v.prId === undefined ? null : { prId: v.prId }),
            };
        });
}

/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponseType$: z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponseType
> = z.nativeEnum(CreateDeploymentGitSourceDeploymentsResponseType);

/** @internal */
export namespace GitSourceRepoId$ {
    export const inboundSchema: z.ZodType<GitSourceRepoId, z.ZodTypeDef, unknown> = z.union([
        z.string(),
        z.number(),
    ]);

    export type Outbound = string | number;
    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, GitSourceRepoId> = z.union([
        z.string(),
        z.number(),
    ]);
}

/** @internal */
export namespace GitSource1$ {
    export const inboundSchema: z.ZodType<GitSource1, z.ZodTypeDef, unknown> = z
        .object({
            type: CreateDeploymentGitSourceDeploymentsResponseType$,
            repoId: z.union([z.string(), z.number()]),
            ref: z.nullable(z.string()).optional(),
            sha: z.string().optional(),
            prId: z.nullable(z.number()).optional(),
        })
        .transform((v) => {
            return {
                type: v.type,
                repoId: v.repoId,
                ...(v.ref === undefined ? null : { ref: v.ref }),
                ...(v.sha === undefined ? null : { sha: v.sha }),
                ...(v.prId === undefined ? null : { prId: v.prId }),
            };
        });

    export type Outbound = {
        type: CreateDeploymentGitSourceDeploymentsResponseType;
        repoId: string | number;
        ref?: string | null | undefined;
        sha?: string | undefined;
        prId?: number | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, GitSource1> = z
        .object({
            type: CreateDeploymentGitSourceDeploymentsResponseType$,
            repoId: z.union([z.string(), z.number()]),
            ref: z.nullable(z.string()).optional(),
            sha: z.string().optional(),
            prId: z.nullable(z.number()).optional(),
        })
        .transform((v) => {
            return {
                type: v.type,
                repoId: v.repoId,
                ...(v.ref === undefined ? null : { ref: v.ref }),
                ...(v.sha === undefined ? null : { sha: v.sha }),
                ...(v.prId === undefined ? null : { prId: v.prId }),
            };
        });
}

/** @internal */
export namespace CreateDeploymentGitSource$ {
    export const inboundSchema: z.ZodType<CreateDeploymentGitSource, z.ZodTypeDef, unknown> =
        z.union([
            z.lazy(() => CreateDeploymentGitSource6$.inboundSchema),
            z.lazy(() => CreateDeploymentGitSource8$.inboundSchema),
            z.lazy(() => GitSource1$.inboundSchema),
            z.lazy(() => GitSource3$.inboundSchema),
            z.lazy(() => GitSource2$.inboundSchema),
            z.lazy(() => GitSource4$.inboundSchema),
            z.lazy(() => GitSource5$.inboundSchema),
            z.lazy(() => CreateDeploymentGitSource7$.inboundSchema),
            z.lazy(() => CreateDeploymentGitSource9$.inboundSchema),
        ]);

    export type Outbound =
        | CreateDeploymentGitSource6$.Outbound
        | CreateDeploymentGitSource8$.Outbound
        | GitSource1$.Outbound
        | GitSource3$.Outbound
        | GitSource2$.Outbound
        | GitSource4$.Outbound
        | GitSource5$.Outbound
        | CreateDeploymentGitSource7$.Outbound
        | CreateDeploymentGitSource9$.Outbound;
    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, CreateDeploymentGitSource> =
        z.union([
            z.lazy(() => CreateDeploymentGitSource6$.outboundSchema),
            z.lazy(() => CreateDeploymentGitSource8$.outboundSchema),
            z.lazy(() => GitSource1$.outboundSchema),
            z.lazy(() => GitSource3$.outboundSchema),
            z.lazy(() => GitSource2$.outboundSchema),
            z.lazy(() => GitSource4$.outboundSchema),
            z.lazy(() => GitSource5$.outboundSchema),
            z.lazy(() => CreateDeploymentGitSource7$.outboundSchema),
            z.lazy(() => CreateDeploymentGitSource9$.outboundSchema),
        ]);
}

/** @internal */
export namespace CreateDeploymentResponseBody$ {
    export const inboundSchema: z.ZodType<CreateDeploymentResponseBody, z.ZodTypeDef, unknown> = z
        .object({
            build: z.lazy(() => Build$.inboundSchema),
            builds: z.array(z.lazy(() => CreateDeploymentBuilds$.inboundSchema)).optional(),
            connectBuildsEnabled: z.boolean().optional(),
            connectConfigurationId: z.string().optional(),
            createdIn: z.string(),
            crons: z.array(z.lazy(() => CreateDeploymentCrons$.inboundSchema)).optional(),
            env: z.array(z.string()),
            functions: z.nullable(z.record(z.lazy(() => Functions$.inboundSchema))).optional(),
            inspectorUrl: z.nullable(z.string()),
            isInConcurrentBuildsQueue: z.boolean(),
            meta: z.record(z.string()),
            monorepoManager: z.nullable(z.string()).optional(),
            name: z.string(),
            ownerId: z.string(),
            passiveConnectConfigurationId: z.string().optional(),
            plan: Plan$,
            projectId: z.string(),
            routes: z.nullable(
                z.array(
                    z.union([
                        z.lazy(() => Routes3$.inboundSchema),
                        z.lazy(() => Routes2$.inboundSchema),
                        z.lazy(() => Routes1$.inboundSchema),
                    ])
                )
            ),
            gitRepo: z
                .nullable(
                    z.union([
                        z.lazy(() => GitRepo1$.inboundSchema),
                        z.lazy(() => GitRepo2$.inboundSchema),
                        z.lazy(() => GitRepo3$.inboundSchema),
                    ])
                )
                .optional(),
            aliasAssignedAt: z.nullable(z.union([z.number(), z.boolean()])).optional(),
            lambdas: z.array(z.lazy(() => Lambdas$.inboundSchema)).optional(),
            project: z.lazy(() => Project$.inboundSchema).optional(),
            public: z.boolean(),
            readyState: CreateDeploymentReadyState$,
            readySubstate: ReadySubstate$.optional(),
            regions: z.array(z.string()),
            source: CreateDeploymentSource$.optional(),
            target: z.nullable(CreateDeploymentTarget$).optional(),
            team: z.lazy(() => Team$.inboundSchema).optional(),
            type: CreateDeploymentType$,
            url: z.string(),
            userAliases: z.array(z.string()).optional(),
            version: z.number(),
            previewCommentsEnabled: z.boolean().optional(),
            alias: z.array(z.string()),
            aliasAssigned: z.boolean(),
            aliasError: z.nullable(z.lazy(() => AliasError$.inboundSchema)).optional(),
            aliasFinal: z.nullable(z.string()).optional(),
            aliasWarning: z.nullable(z.lazy(() => AliasWarning$.inboundSchema)).optional(),
            autoAssignCustomDomains: z.boolean().optional(),
            automaticAliases: z.array(z.string()).optional(),
            bootedAt: z.number(),
            buildErrorAt: z.number().optional(),
            buildingAt: z.number(),
            canceledAt: z.number().optional(),
            checksState: ChecksState$.optional(),
            checksConclusion: ChecksConclusion$.optional(),
            createdAt: z.number(),
            creator: z.lazy(() => Creator$.inboundSchema),
            errorCode: z.string().optional(),
            errorLink: z.string().optional(),
            errorMessage: z.nullable(z.string()).optional(),
            errorStep: z.string().optional(),
            passiveRegions: z.array(z.string()).optional(),
            gitSource: z
                .union([
                    z.lazy(() => CreateDeploymentGitSource6$.inboundSchema),
                    z.lazy(() => CreateDeploymentGitSource8$.inboundSchema),
                    z.lazy(() => GitSource1$.inboundSchema),
                    z.lazy(() => GitSource3$.inboundSchema),
                    z.lazy(() => GitSource2$.inboundSchema),
                    z.lazy(() => GitSource4$.inboundSchema),
                    z.lazy(() => GitSource5$.inboundSchema),
                    z.lazy(() => CreateDeploymentGitSource7$.inboundSchema),
                    z.lazy(() => CreateDeploymentGitSource9$.inboundSchema),
                ])
                .optional(),
            id: z.string(),
        })
        .transform((v) => {
            return {
                build: v.build,
                ...(v.builds === undefined ? null : { builds: v.builds }),
                ...(v.connectBuildsEnabled === undefined
                    ? null
                    : { connectBuildsEnabled: v.connectBuildsEnabled }),
                ...(v.connectConfigurationId === undefined
                    ? null
                    : { connectConfigurationId: v.connectConfigurationId }),
                createdIn: v.createdIn,
                ...(v.crons === undefined ? null : { crons: v.crons }),
                env: v.env,
                ...(v.functions === undefined ? null : { functions: v.functions }),
                inspectorUrl: v.inspectorUrl,
                isInConcurrentBuildsQueue: v.isInConcurrentBuildsQueue,
                meta: v.meta,
                ...(v.monorepoManager === undefined
                    ? null
                    : { monorepoManager: v.monorepoManager }),
                name: v.name,
                ownerId: v.ownerId,
                ...(v.passiveConnectConfigurationId === undefined
                    ? null
                    : { passiveConnectConfigurationId: v.passiveConnectConfigurationId }),
                plan: v.plan,
                projectId: v.projectId,
                routes: v.routes,
                ...(v.gitRepo === undefined ? null : { gitRepo: v.gitRepo }),
                ...(v.aliasAssignedAt === undefined
                    ? null
                    : { aliasAssignedAt: v.aliasAssignedAt }),
                ...(v.lambdas === undefined ? null : { lambdas: v.lambdas }),
                ...(v.project === undefined ? null : { project: v.project }),
                public: v.public,
                readyState: v.readyState,
                ...(v.readySubstate === undefined ? null : { readySubstate: v.readySubstate }),
                regions: v.regions,
                ...(v.source === undefined ? null : { source: v.source }),
                ...(v.target === undefined ? null : { target: v.target }),
                ...(v.team === undefined ? null : { team: v.team }),
                type: v.type,
                url: v.url,
                ...(v.userAliases === undefined ? null : { userAliases: v.userAliases }),
                version: v.version,
                ...(v.previewCommentsEnabled === undefined
                    ? null
                    : { previewCommentsEnabled: v.previewCommentsEnabled }),
                alias: v.alias,
                aliasAssigned: v.aliasAssigned,
                ...(v.aliasError === undefined ? null : { aliasError: v.aliasError }),
                ...(v.aliasFinal === undefined ? null : { aliasFinal: v.aliasFinal }),
                ...(v.aliasWarning === undefined ? null : { aliasWarning: v.aliasWarning }),
                ...(v.autoAssignCustomDomains === undefined
                    ? null
                    : { autoAssignCustomDomains: v.autoAssignCustomDomains }),
                ...(v.automaticAliases === undefined
                    ? null
                    : { automaticAliases: v.automaticAliases }),
                bootedAt: v.bootedAt,
                ...(v.buildErrorAt === undefined ? null : { buildErrorAt: v.buildErrorAt }),
                buildingAt: v.buildingAt,
                ...(v.canceledAt === undefined ? null : { canceledAt: v.canceledAt }),
                ...(v.checksState === undefined ? null : { checksState: v.checksState }),
                ...(v.checksConclusion === undefined
                    ? null
                    : { checksConclusion: v.checksConclusion }),
                createdAt: v.createdAt,
                creator: v.creator,
                ...(v.errorCode === undefined ? null : { errorCode: v.errorCode }),
                ...(v.errorLink === undefined ? null : { errorLink: v.errorLink }),
                ...(v.errorMessage === undefined ? null : { errorMessage: v.errorMessage }),
                ...(v.errorStep === undefined ? null : { errorStep: v.errorStep }),
                ...(v.passiveRegions === undefined ? null : { passiveRegions: v.passiveRegions }),
                ...(v.gitSource === undefined ? null : { gitSource: v.gitSource }),
                id: v.id,
            };
        });

    export type Outbound = {
        build: Build$.Outbound;
        builds?: Array<CreateDeploymentBuilds$.Outbound> | undefined;
        connectBuildsEnabled?: boolean | undefined;
        connectConfigurationId?: string | undefined;
        createdIn: string;
        crons?: Array<CreateDeploymentCrons$.Outbound> | undefined;
        env: Array<string>;
        functions?: Record<string, Functions$.Outbound> | null | undefined;
        inspectorUrl: string | null;
        isInConcurrentBuildsQueue: boolean;
        meta: Record<string, string>;
        monorepoManager?: string | null | undefined;
        name: string;
        ownerId: string;
        passiveConnectConfigurationId?: string | undefined;
        plan: Plan;
        projectId: string;
        routes: Array<Routes3$.Outbound | Routes2$.Outbound | Routes1$.Outbound> | null;
        gitRepo?: GitRepo1$.Outbound | GitRepo2$.Outbound | GitRepo3$.Outbound | null | undefined;
        aliasAssignedAt?: number | boolean | null | undefined;
        lambdas?: Array<Lambdas$.Outbound> | undefined;
        project?: Project$.Outbound | undefined;
        public: boolean;
        readyState: CreateDeploymentReadyState;
        readySubstate?: ReadySubstate | undefined;
        regions: Array<string>;
        source?: CreateDeploymentSource | undefined;
        target?: CreateDeploymentTarget | null | undefined;
        team?: Team$.Outbound | undefined;
        type: CreateDeploymentType;
        url: string;
        userAliases?: Array<string> | undefined;
        version: number;
        previewCommentsEnabled?: boolean | undefined;
        alias: Array<string>;
        aliasAssigned: boolean;
        aliasError?: AliasError$.Outbound | null | undefined;
        aliasFinal?: string | null | undefined;
        aliasWarning?: AliasWarning$.Outbound | null | undefined;
        autoAssignCustomDomains?: boolean | undefined;
        automaticAliases?: Array<string> | undefined;
        bootedAt: number;
        buildErrorAt?: number | undefined;
        buildingAt: number;
        canceledAt?: number | undefined;
        checksState?: ChecksState | undefined;
        checksConclusion?: ChecksConclusion | undefined;
        createdAt: number;
        creator: Creator$.Outbound;
        errorCode?: string | undefined;
        errorLink?: string | undefined;
        errorMessage?: string | null | undefined;
        errorStep?: string | undefined;
        passiveRegions?: Array<string> | undefined;
        gitSource?:
            | CreateDeploymentGitSource6$.Outbound
            | CreateDeploymentGitSource8$.Outbound
            | GitSource1$.Outbound
            | GitSource3$.Outbound
            | GitSource2$.Outbound
            | GitSource4$.Outbound
            | GitSource5$.Outbound
            | CreateDeploymentGitSource7$.Outbound
            | CreateDeploymentGitSource9$.Outbound
            | undefined;
        id: string;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, CreateDeploymentResponseBody> = z
        .object({
            build: z.lazy(() => Build$.outboundSchema),
            builds: z.array(z.lazy(() => CreateDeploymentBuilds$.outboundSchema)).optional(),
            connectBuildsEnabled: z.boolean().optional(),
            connectConfigurationId: z.string().optional(),
            createdIn: z.string(),
            crons: z.array(z.lazy(() => CreateDeploymentCrons$.outboundSchema)).optional(),
            env: z.array(z.string()),
            functions: z.nullable(z.record(z.lazy(() => Functions$.outboundSchema))).optional(),
            inspectorUrl: z.nullable(z.string()),
            isInConcurrentBuildsQueue: z.boolean(),
            meta: z.record(z.string()),
            monorepoManager: z.nullable(z.string()).optional(),
            name: z.string(),
            ownerId: z.string(),
            passiveConnectConfigurationId: z.string().optional(),
            plan: Plan$,
            projectId: z.string(),
            routes: z.nullable(
                z.array(
                    z.union([
                        z.lazy(() => Routes3$.outboundSchema),
                        z.lazy(() => Routes2$.outboundSchema),
                        z.lazy(() => Routes1$.outboundSchema),
                    ])
                )
            ),
            gitRepo: z
                .nullable(
                    z.union([
                        z.lazy(() => GitRepo1$.outboundSchema),
                        z.lazy(() => GitRepo2$.outboundSchema),
                        z.lazy(() => GitRepo3$.outboundSchema),
                    ])
                )
                .optional(),
            aliasAssignedAt: z.nullable(z.union([z.number(), z.boolean()])).optional(),
            lambdas: z.array(z.lazy(() => Lambdas$.outboundSchema)).optional(),
            project: z.lazy(() => Project$.outboundSchema).optional(),
            public: z.boolean(),
            readyState: CreateDeploymentReadyState$,
            readySubstate: ReadySubstate$.optional(),
            regions: z.array(z.string()),
            source: CreateDeploymentSource$.optional(),
            target: z.nullable(CreateDeploymentTarget$).optional(),
            team: z.lazy(() => Team$.outboundSchema).optional(),
            type: CreateDeploymentType$,
            url: z.string(),
            userAliases: z.array(z.string()).optional(),
            version: z.number(),
            previewCommentsEnabled: z.boolean().optional(),
            alias: z.array(z.string()),
            aliasAssigned: z.boolean(),
            aliasError: z.nullable(z.lazy(() => AliasError$.outboundSchema)).optional(),
            aliasFinal: z.nullable(z.string()).optional(),
            aliasWarning: z.nullable(z.lazy(() => AliasWarning$.outboundSchema)).optional(),
            autoAssignCustomDomains: z.boolean().optional(),
            automaticAliases: z.array(z.string()).optional(),
            bootedAt: z.number(),
            buildErrorAt: z.number().optional(),
            buildingAt: z.number(),
            canceledAt: z.number().optional(),
            checksState: ChecksState$.optional(),
            checksConclusion: ChecksConclusion$.optional(),
            createdAt: z.number(),
            creator: z.lazy(() => Creator$.outboundSchema),
            errorCode: z.string().optional(),
            errorLink: z.string().optional(),
            errorMessage: z.nullable(z.string()).optional(),
            errorStep: z.string().optional(),
            passiveRegions: z.array(z.string()).optional(),
            gitSource: z
                .union([
                    z.lazy(() => CreateDeploymentGitSource6$.outboundSchema),
                    z.lazy(() => CreateDeploymentGitSource8$.outboundSchema),
                    z.lazy(() => GitSource1$.outboundSchema),
                    z.lazy(() => GitSource3$.outboundSchema),
                    z.lazy(() => GitSource2$.outboundSchema),
                    z.lazy(() => GitSource4$.outboundSchema),
                    z.lazy(() => GitSource5$.outboundSchema),
                    z.lazy(() => CreateDeploymentGitSource7$.outboundSchema),
                    z.lazy(() => CreateDeploymentGitSource9$.outboundSchema),
                ])
                .optional(),
            id: z.string(),
        })
        .transform((v) => {
            return {
                build: v.build,
                ...(v.builds === undefined ? null : { builds: v.builds }),
                ...(v.connectBuildsEnabled === undefined
                    ? null
                    : { connectBuildsEnabled: v.connectBuildsEnabled }),
                ...(v.connectConfigurationId === undefined
                    ? null
                    : { connectConfigurationId: v.connectConfigurationId }),
                createdIn: v.createdIn,
                ...(v.crons === undefined ? null : { crons: v.crons }),
                env: v.env,
                ...(v.functions === undefined ? null : { functions: v.functions }),
                inspectorUrl: v.inspectorUrl,
                isInConcurrentBuildsQueue: v.isInConcurrentBuildsQueue,
                meta: v.meta,
                ...(v.monorepoManager === undefined
                    ? null
                    : { monorepoManager: v.monorepoManager }),
                name: v.name,
                ownerId: v.ownerId,
                ...(v.passiveConnectConfigurationId === undefined
                    ? null
                    : { passiveConnectConfigurationId: v.passiveConnectConfigurationId }),
                plan: v.plan,
                projectId: v.projectId,
                routes: v.routes,
                ...(v.gitRepo === undefined ? null : { gitRepo: v.gitRepo }),
                ...(v.aliasAssignedAt === undefined
                    ? null
                    : { aliasAssignedAt: v.aliasAssignedAt }),
                ...(v.lambdas === undefined ? null : { lambdas: v.lambdas }),
                ...(v.project === undefined ? null : { project: v.project }),
                public: v.public,
                readyState: v.readyState,
                ...(v.readySubstate === undefined ? null : { readySubstate: v.readySubstate }),
                regions: v.regions,
                ...(v.source === undefined ? null : { source: v.source }),
                ...(v.target === undefined ? null : { target: v.target }),
                ...(v.team === undefined ? null : { team: v.team }),
                type: v.type,
                url: v.url,
                ...(v.userAliases === undefined ? null : { userAliases: v.userAliases }),
                version: v.version,
                ...(v.previewCommentsEnabled === undefined
                    ? null
                    : { previewCommentsEnabled: v.previewCommentsEnabled }),
                alias: v.alias,
                aliasAssigned: v.aliasAssigned,
                ...(v.aliasError === undefined ? null : { aliasError: v.aliasError }),
                ...(v.aliasFinal === undefined ? null : { aliasFinal: v.aliasFinal }),
                ...(v.aliasWarning === undefined ? null : { aliasWarning: v.aliasWarning }),
                ...(v.autoAssignCustomDomains === undefined
                    ? null
                    : { autoAssignCustomDomains: v.autoAssignCustomDomains }),
                ...(v.automaticAliases === undefined
                    ? null
                    : { automaticAliases: v.automaticAliases }),
                bootedAt: v.bootedAt,
                ...(v.buildErrorAt === undefined ? null : { buildErrorAt: v.buildErrorAt }),
                buildingAt: v.buildingAt,
                ...(v.canceledAt === undefined ? null : { canceledAt: v.canceledAt }),
                ...(v.checksState === undefined ? null : { checksState: v.checksState }),
                ...(v.checksConclusion === undefined
                    ? null
                    : { checksConclusion: v.checksConclusion }),
                createdAt: v.createdAt,
                creator: v.creator,
                ...(v.errorCode === undefined ? null : { errorCode: v.errorCode }),
                ...(v.errorLink === undefined ? null : { errorLink: v.errorLink }),
                ...(v.errorMessage === undefined ? null : { errorMessage: v.errorMessage }),
                ...(v.errorStep === undefined ? null : { errorStep: v.errorStep }),
                ...(v.passiveRegions === undefined ? null : { passiveRegions: v.passiveRegions }),
                ...(v.gitSource === undefined ? null : { gitSource: v.gitSource }),
                id: v.id,
            };
        });
}

/** @internal */
export namespace CreateDeploymentResponse$ {
    export const inboundSchema: z.ZodType<CreateDeploymentResponse, z.ZodTypeDef, unknown> = z
        .object({
            HttpMeta: components.HTTPMetadata$.inboundSchema,
            object: z.lazy(() => CreateDeploymentResponseBody$.inboundSchema).optional(),
        })
        .transform((v) => {
            return {
                httpMeta: v.HttpMeta,
                ...(v.object === undefined ? null : { object: v.object }),
            };
        });

    export type Outbound = {
        HttpMeta: components.HTTPMetadata$.Outbound;
        object?: CreateDeploymentResponseBody$.Outbound | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, CreateDeploymentResponse> = z
        .object({
            httpMeta: components.HTTPMetadata$.outboundSchema,
            object: z.lazy(() => CreateDeploymentResponseBody$.outboundSchema).optional(),
        })
        .transform((v) => {
            return {
                HttpMeta: v.httpMeta,
                ...(v.object === undefined ? null : { object: v.object }),
            };
        });
}
