/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as components from "../components";
import * as z from "zod";

/**
 * The delivery log format
 */
export enum DeliveryFormat {
    Json = "json",
    Ndjson = "ndjson",
    Syslog = "syslog",
}

export enum Sources {
    Static = "static",
    Lambda = "lambda",
    Build = "build",
    Edge = "edge",
    External = "external",
}

export enum Environments {
    Preview = "preview",
    Production = "production",
}

export type CreateLogDrainRequestBody = {
    /**
     * The name of the log drain
     */
    name: string;
    projectIds?: Array<string> | undefined;
    /**
     * A secret to sign log drain notification headers so a consumer can verify their authenticity
     */
    secret?: string | undefined;
    /**
     * The delivery log format
     */
    deliveryFormat?: DeliveryFormat | undefined;
    /**
     * The url where you will receive logs. The protocol must be `https://` or `http://` when type is `json` and `ndjson`, and `syslog+tls:` or `syslog:` when the type is `syslog`.
     */
    url: string;
    sources?: Array<Sources> | undefined;
    /**
     * Headers to be sent together with the request
     */
    headers?: Record<string, string> | undefined;
    environments?: Array<Environments> | undefined;
};

export type CreateLogDrainRequest = {
    /**
     * The Team identifier to perform the request on behalf of.
     */
    teamId?: string | undefined;
    /**
     * The Team slug to perform the request on behalf of.
     */
    slug?: string | undefined;
    requestBody?: CreateLogDrainRequestBody | undefined;
};

/**
 * The delivery log format
 */
export enum CreateLogDrainDeliveryFormat {
    Json = "json",
    Ndjson = "ndjson",
    Syslog = "syslog",
}

/**
 * The sources from which logs are currently being delivered to this log drain.
 */
export enum CreateLogDrainSources {
    Build = "build",
    Edge = "edge",
    Lambda = "lambda",
    Static = "static",
    External = "external",
}

/**
 * Whether the log drain was created by an integration or by a user
 */
export enum CreateLogDrainCreatedFrom {
    SelfServed = "self-served",
    Integration = "integration",
}

/**
 * The environment of log drain
 */
export enum CreateLogDrainEnvironments {
    Production = "production",
    Preview = "preview",
}

/**
 * The log drain was successfully created
 */
export type CreateLogDrainResponseBody = {
    /**
     * The oauth2 client application id that created this log drain
     */
    clientId?: string | undefined;
    /**
     * The client configuration this log drain was created with
     */
    configurationId?: string | undefined;
    /**
     * A timestamp that tells you when the log drain was created
     */
    createdAt: number;
    /**
     * The unique identifier of the log drain. Always prefixed with `ld_`
     */
    id: string;
    /**
     * The delivery log format
     */
    deliveryFormat?: CreateLogDrainDeliveryFormat | undefined;
    /**
     * The name of the log drain
     */
    name: string;
    /**
     * The identifier of the team or user whose events will trigger the log drain
     */
    ownerId: string;
    projectId?: string | null | undefined;
    /**
     * The identifier of the projects this log drain is associated with
     */
    projectIds?: Array<string> | undefined;
    /**
     * The URL to call when logs are generated
     */
    url: string;
    /**
     * The sources from which logs are currently being delivered to this log drain.
     */
    sources?: Array<CreateLogDrainSources> | undefined;
    /**
     * Whether the log drain was created by an integration or by a user
     */
    createdFrom?: CreateLogDrainCreatedFrom | undefined;
    /**
     * The headers to send with the request
     */
    headers?: Record<string, string> | undefined;
    /**
     * The environment of log drain
     */
    environments: Array<CreateLogDrainEnvironments>;
    /**
     * The branch regexp of log drain
     */
    branch?: string | undefined;
    /**
     * The sampling rate of log drain
     */
    samplingRate?: number | undefined;
};

export type CreateLogDrainResponse = {
    httpMeta: components.HTTPMetadata;
    /**
     * The log drain was successfully created
     */
    object?: CreateLogDrainResponseBody | undefined;
};

/** @internal */
export namespace DeliveryFormat$ {
    export const inboundSchema = z.nativeEnum(DeliveryFormat);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace Sources$ {
    export const inboundSchema = z.nativeEnum(Sources);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace Environments$ {
    export const inboundSchema = z.nativeEnum(Environments);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace CreateLogDrainRequestBody$ {
    export const inboundSchema: z.ZodType<CreateLogDrainRequestBody, z.ZodTypeDef, unknown> = z
        .object({
            name: z.string(),
            projectIds: z.array(z.string()).optional(),
            secret: z.string().optional(),
            deliveryFormat: DeliveryFormat$.inboundSchema.optional(),
            url: z.string(),
            sources: z.array(Sources$.inboundSchema).optional(),
            headers: z.record(z.string()).optional(),
            environments: z.array(Environments$.inboundSchema).optional(),
        })
        .transform((v) => {
            return {
                name: v.name,
                ...(v.projectIds === undefined ? null : { projectIds: v.projectIds }),
                ...(v.secret === undefined ? null : { secret: v.secret }),
                ...(v.deliveryFormat === undefined ? null : { deliveryFormat: v.deliveryFormat }),
                url: v.url,
                ...(v.sources === undefined ? null : { sources: v.sources }),
                ...(v.headers === undefined ? null : { headers: v.headers }),
                ...(v.environments === undefined ? null : { environments: v.environments }),
            };
        });

    export type Outbound = {
        name: string;
        projectIds?: Array<string> | undefined;
        secret?: string | undefined;
        deliveryFormat?: string | undefined;
        url: string;
        sources?: Array<string> | undefined;
        headers?: Record<string, string> | undefined;
        environments?: Array<string> | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, CreateLogDrainRequestBody> = z
        .object({
            name: z.string(),
            projectIds: z.array(z.string()).optional(),
            secret: z.string().optional(),
            deliveryFormat: DeliveryFormat$.outboundSchema.optional(),
            url: z.string(),
            sources: z.array(Sources$.outboundSchema).optional(),
            headers: z.record(z.string()).optional(),
            environments: z.array(Environments$.outboundSchema).optional(),
        })
        .transform((v) => {
            return {
                name: v.name,
                ...(v.projectIds === undefined ? null : { projectIds: v.projectIds }),
                ...(v.secret === undefined ? null : { secret: v.secret }),
                ...(v.deliveryFormat === undefined ? null : { deliveryFormat: v.deliveryFormat }),
                url: v.url,
                ...(v.sources === undefined ? null : { sources: v.sources }),
                ...(v.headers === undefined ? null : { headers: v.headers }),
                ...(v.environments === undefined ? null : { environments: v.environments }),
            };
        });
}

/** @internal */
export namespace CreateLogDrainRequest$ {
    export const inboundSchema: z.ZodType<CreateLogDrainRequest, z.ZodTypeDef, unknown> = z
        .object({
            teamId: z.string().optional(),
            slug: z.string().optional(),
            RequestBody: z.lazy(() => CreateLogDrainRequestBody$.inboundSchema).optional(),
        })
        .transform((v) => {
            return {
                ...(v.teamId === undefined ? null : { teamId: v.teamId }),
                ...(v.slug === undefined ? null : { slug: v.slug }),
                ...(v.RequestBody === undefined ? null : { requestBody: v.RequestBody }),
            };
        });

    export type Outbound = {
        teamId?: string | undefined;
        slug?: string | undefined;
        RequestBody?: CreateLogDrainRequestBody$.Outbound | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, CreateLogDrainRequest> = z
        .object({
            teamId: z.string().optional(),
            slug: z.string().optional(),
            requestBody: z.lazy(() => CreateLogDrainRequestBody$.outboundSchema).optional(),
        })
        .transform((v) => {
            return {
                ...(v.teamId === undefined ? null : { teamId: v.teamId }),
                ...(v.slug === undefined ? null : { slug: v.slug }),
                ...(v.requestBody === undefined ? null : { RequestBody: v.requestBody }),
            };
        });
}

/** @internal */
export namespace CreateLogDrainDeliveryFormat$ {
    export const inboundSchema = z.nativeEnum(CreateLogDrainDeliveryFormat);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace CreateLogDrainSources$ {
    export const inboundSchema = z.nativeEnum(CreateLogDrainSources);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace CreateLogDrainCreatedFrom$ {
    export const inboundSchema = z.nativeEnum(CreateLogDrainCreatedFrom);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace CreateLogDrainEnvironments$ {
    export const inboundSchema = z.nativeEnum(CreateLogDrainEnvironments);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace CreateLogDrainResponseBody$ {
    export const inboundSchema: z.ZodType<CreateLogDrainResponseBody, z.ZodTypeDef, unknown> = z
        .object({
            clientId: z.string().optional(),
            configurationId: z.string().optional(),
            createdAt: z.number(),
            id: z.string(),
            deliveryFormat: CreateLogDrainDeliveryFormat$.inboundSchema.optional(),
            name: z.string(),
            ownerId: z.string(),
            projectId: z.nullable(z.string()).optional(),
            projectIds: z.array(z.string()).optional(),
            url: z.string(),
            sources: z.array(CreateLogDrainSources$.inboundSchema).optional(),
            createdFrom: CreateLogDrainCreatedFrom$.inboundSchema.optional(),
            headers: z.record(z.string()).optional(),
            environments: z.array(CreateLogDrainEnvironments$.inboundSchema),
            branch: z.string().optional(),
            samplingRate: z.number().optional(),
        })
        .transform((v) => {
            return {
                ...(v.clientId === undefined ? null : { clientId: v.clientId }),
                ...(v.configurationId === undefined
                    ? null
                    : { configurationId: v.configurationId }),
                createdAt: v.createdAt,
                id: v.id,
                ...(v.deliveryFormat === undefined ? null : { deliveryFormat: v.deliveryFormat }),
                name: v.name,
                ownerId: v.ownerId,
                ...(v.projectId === undefined ? null : { projectId: v.projectId }),
                ...(v.projectIds === undefined ? null : { projectIds: v.projectIds }),
                url: v.url,
                ...(v.sources === undefined ? null : { sources: v.sources }),
                ...(v.createdFrom === undefined ? null : { createdFrom: v.createdFrom }),
                ...(v.headers === undefined ? null : { headers: v.headers }),
                environments: v.environments,
                ...(v.branch === undefined ? null : { branch: v.branch }),
                ...(v.samplingRate === undefined ? null : { samplingRate: v.samplingRate }),
            };
        });

    export type Outbound = {
        clientId?: string | undefined;
        configurationId?: string | undefined;
        createdAt: number;
        id: string;
        deliveryFormat?: string | undefined;
        name: string;
        ownerId: string;
        projectId?: string | null | undefined;
        projectIds?: Array<string> | undefined;
        url: string;
        sources?: Array<string> | undefined;
        createdFrom?: string | undefined;
        headers?: Record<string, string> | undefined;
        environments: Array<string>;
        branch?: string | undefined;
        samplingRate?: number | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, CreateLogDrainResponseBody> = z
        .object({
            clientId: z.string().optional(),
            configurationId: z.string().optional(),
            createdAt: z.number(),
            id: z.string(),
            deliveryFormat: CreateLogDrainDeliveryFormat$.outboundSchema.optional(),
            name: z.string(),
            ownerId: z.string(),
            projectId: z.nullable(z.string()).optional(),
            projectIds: z.array(z.string()).optional(),
            url: z.string(),
            sources: z.array(CreateLogDrainSources$.outboundSchema).optional(),
            createdFrom: CreateLogDrainCreatedFrom$.outboundSchema.optional(),
            headers: z.record(z.string()).optional(),
            environments: z.array(CreateLogDrainEnvironments$.outboundSchema),
            branch: z.string().optional(),
            samplingRate: z.number().optional(),
        })
        .transform((v) => {
            return {
                ...(v.clientId === undefined ? null : { clientId: v.clientId }),
                ...(v.configurationId === undefined
                    ? null
                    : { configurationId: v.configurationId }),
                createdAt: v.createdAt,
                id: v.id,
                ...(v.deliveryFormat === undefined ? null : { deliveryFormat: v.deliveryFormat }),
                name: v.name,
                ownerId: v.ownerId,
                ...(v.projectId === undefined ? null : { projectId: v.projectId }),
                ...(v.projectIds === undefined ? null : { projectIds: v.projectIds }),
                url: v.url,
                ...(v.sources === undefined ? null : { sources: v.sources }),
                ...(v.createdFrom === undefined ? null : { createdFrom: v.createdFrom }),
                ...(v.headers === undefined ? null : { headers: v.headers }),
                environments: v.environments,
                ...(v.branch === undefined ? null : { branch: v.branch }),
                ...(v.samplingRate === undefined ? null : { samplingRate: v.samplingRate }),
            };
        });
}

/** @internal */
export namespace CreateLogDrainResponse$ {
    export const inboundSchema: z.ZodType<CreateLogDrainResponse, z.ZodTypeDef, unknown> = z
        .object({
            HttpMeta: components.HTTPMetadata$.inboundSchema,
            object: z.lazy(() => CreateLogDrainResponseBody$.inboundSchema).optional(),
        })
        .transform((v) => {
            return {
                httpMeta: v.HttpMeta,
                ...(v.object === undefined ? null : { object: v.object }),
            };
        });

    export type Outbound = {
        HttpMeta: components.HTTPMetadata$.Outbound;
        object?: CreateLogDrainResponseBody$.Outbound | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, CreateLogDrainResponse> = z
        .object({
            httpMeta: components.HTTPMetadata$.outboundSchema,
            object: z.lazy(() => CreateLogDrainResponseBody$.outboundSchema).optional(),
        })
        .transform((v) => {
            return {
                HttpMeta: v.httpMeta,
                ...(v.object === undefined ? null : { object: v.object }),
            };
        });
}
