/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as components from "../components";
import * as z from "zod";

export enum View {
    Account = "account",
    Project = "project",
}

export type GetConfigurationsRequest = {
    view: View;
    /**
     * The Team identifier to perform the request on behalf of.
     */
    teamId?: string | undefined;
    /**
     * The Team slug to perform the request on behalf of.
     */
    slug?: string | undefined;
};

export type Integration = {
    name: string;
    icon: string;
    category: string;
    isLegacy: boolean;
    flags?: Array<string> | undefined;
    assignedBetaLabelAt?: number | undefined;
};

/**
 * Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.
 */
export enum GetConfigurationsResponseBodyIntegrationsSource {
    Marketplace = "marketplace",
    DeployButton = "deploy-button",
    External = "external",
}

export enum GetConfigurationsResponseBodyIntegrationsType {
    IntegrationConfiguration = "integration-configuration",
}

export enum ResponseBodyAdded {
    ReadIntegrationConfiguration = "read:integration-configuration",
    ReadWriteIntegrationConfiguration = "read-write:integration-configuration",
    ReadDeployment = "read:deployment",
    ReadWriteDeployment = "read-write:deployment",
    ReadWriteDeploymentCheck = "read-write:deployment-check",
    ReadProject = "read:project",
    ReadWriteProject = "read-write:project",
    ReadWriteProjectEnvVars = "read-write:project-env-vars",
    ReadWriteGlobalProjectEnvVars = "read-write:global-project-env-vars",
    ReadTeam = "read:team",
    ReadUser = "read:user",
    ReadWriteLogDrain = "read-write:log-drain",
    ReadDomain = "read:domain",
    ReadWriteDomain = "read-write:domain",
    ReadWriteEdgeConfig = "read-write:edge-config",
    ReadWriteOtelEndpoint = "read-write:otel-endpoint",
    ReadMonitoring = "read:monitoring",
    ReadWriteIntegrationResource = "read-write:integration-resource",
}

export enum ResponseBodyUpgraded {
    ReadIntegrationConfiguration = "read:integration-configuration",
    ReadWriteIntegrationConfiguration = "read-write:integration-configuration",
    ReadDeployment = "read:deployment",
    ReadWriteDeployment = "read-write:deployment",
    ReadWriteDeploymentCheck = "read-write:deployment-check",
    ReadProject = "read:project",
    ReadWriteProject = "read-write:project",
    ReadWriteProjectEnvVars = "read-write:project-env-vars",
    ReadWriteGlobalProjectEnvVars = "read-write:global-project-env-vars",
    ReadTeam = "read:team",
    ReadUser = "read:user",
    ReadWriteLogDrain = "read-write:log-drain",
    ReadDomain = "read:domain",
    ReadWriteDomain = "read-write:domain",
    ReadWriteEdgeConfig = "read-write:edge-config",
    ReadWriteOtelEndpoint = "read-write:otel-endpoint",
    ReadMonitoring = "read:monitoring",
    ReadWriteIntegrationResource = "read-write:integration-resource",
}

export type ResponseBodyScopes = {
    added: Array<ResponseBodyAdded>;
    upgraded: Array<ResponseBodyUpgraded>;
};

export type ResponseBodyScopesQueue = {
    scopes: ResponseBodyScopes;
    note: string;
    requestedAt: number;
    confirmedAt?: number | undefined;
};

export enum ResponseBodyDisabledReason {
    DisabledByOwner = "disabled-by-owner",
    FeatureNotAvailable = "feature-not-available",
    DisabledByAdmin = "disabled-by-admin",
    OriginalOwnerLeftTheTeam = "original-owner-left-the-team",
}

/**
 * Defines the installation type. - 'external' integrations are installed via the existing integrations flow - 'marketplace' integrations are natively installed: - when accepting the TOS of a partner during the store creation process - if undefined, assume 'external'
 */
export enum ResponseBodyInstallationType {
    Marketplace = "marketplace",
    External = "external",
}

export type GetConfigurationsResponseBody2 = {
    integration: Integration;
    /**
     * A timestamp that tells you when the configuration was installed successfully
     */
    completedAt?: number | undefined;
    /**
     * A timestamp that tells you when the configuration was created
     */
    createdAt: number;
    /**
     * The unique identifier of the configuration
     */
    id: string;
    /**
     * The unique identifier of the app the configuration was created for
     */
    integrationId: string;
    /**
     * The user or team ID that owns the configuration
     */
    ownerId: string;
    /**
     * When a configuration is limited to access certain projects, this will contain each of the project ID it is allowed to access. If it is not defined, the configuration has full access.
     */
    projects?: Array<string> | undefined;
    /**
     * Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.
     */
    source?: GetConfigurationsResponseBodyIntegrationsSource | undefined;
    removedLogDrainsAt?: number | undefined;
    removedProjectEnvsAt?: number | undefined;
    removedTokensAt?: number | undefined;
    removedWebhooksAt?: number | undefined;
    /**
     * The slug of the integration the configuration is created for.
     */
    slug: string;
    /**
     * When the configuration was created for a team, this will show the ID of the team.
     */
    teamId?: string | null | undefined;
    type: GetConfigurationsResponseBodyIntegrationsType;
    /**
     * A timestamp that tells you when the configuration was updated.
     */
    updatedAt: number;
    /**
     * The ID of the user that created the configuration.
     */
    userId: string;
    /**
     * The resources that are allowed to be accessed by the configuration.
     */
    scopes: Array<string>;
    scopesQueue?: Array<ResponseBodyScopesQueue> | undefined;
    /**
     * A timestamp that tells you when the configuration was disabled. Note: Configurations can be disabled when the associated user loses access to a team. They do not function during this time until the configuration is 'transferred', meaning the associated user is changed to one with access to the team.
     */
    disabledAt?: number | undefined;
    /**
     * A timestamp that tells you when the configuration was updated.
     */
    deletedAt?: number | null | undefined;
    disabledReason?: ResponseBodyDisabledReason | undefined;
    /**
     * A timestamp that tells you when the configuration was migrated as part of the Northstar migration. In the future, if we allow integration configurations to be transferred between teams, this field should be cleared upon transfer.
     */
    northstarMigratedAt?: number | undefined;
    /**
     * Defines the installation type. - 'external' integrations are installed via the existing integrations flow - 'marketplace' integrations are natively installed: - when accepting the TOS of a partner during the store creation process - if undefined, assume 'external'
     */
    installationType?: ResponseBodyInstallationType | undefined;
};

/**
 * Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.
 */
export enum GetConfigurationsResponseBodySource {
    Marketplace = "marketplace",
    DeployButton = "deploy-button",
    External = "external",
}

export enum GetConfigurationsResponseBodyType {
    IntegrationConfiguration = "integration-configuration",
}

export enum Added {
    ReadIntegrationConfiguration = "read:integration-configuration",
    ReadWriteIntegrationConfiguration = "read-write:integration-configuration",
    ReadDeployment = "read:deployment",
    ReadWriteDeployment = "read-write:deployment",
    ReadWriteDeploymentCheck = "read-write:deployment-check",
    ReadProject = "read:project",
    ReadWriteProject = "read-write:project",
    ReadWriteProjectEnvVars = "read-write:project-env-vars",
    ReadWriteGlobalProjectEnvVars = "read-write:global-project-env-vars",
    ReadTeam = "read:team",
    ReadUser = "read:user",
    ReadWriteLogDrain = "read-write:log-drain",
    ReadDomain = "read:domain",
    ReadWriteDomain = "read-write:domain",
    ReadWriteEdgeConfig = "read-write:edge-config",
    ReadWriteOtelEndpoint = "read-write:otel-endpoint",
    ReadMonitoring = "read:monitoring",
    ReadWriteIntegrationResource = "read-write:integration-resource",
}

export enum Upgraded {
    ReadIntegrationConfiguration = "read:integration-configuration",
    ReadWriteIntegrationConfiguration = "read-write:integration-configuration",
    ReadDeployment = "read:deployment",
    ReadWriteDeployment = "read-write:deployment",
    ReadWriteDeploymentCheck = "read-write:deployment-check",
    ReadProject = "read:project",
    ReadWriteProject = "read-write:project",
    ReadWriteProjectEnvVars = "read-write:project-env-vars",
    ReadWriteGlobalProjectEnvVars = "read-write:global-project-env-vars",
    ReadTeam = "read:team",
    ReadUser = "read:user",
    ReadWriteLogDrain = "read-write:log-drain",
    ReadDomain = "read:domain",
    ReadWriteDomain = "read-write:domain",
    ReadWriteEdgeConfig = "read-write:edge-config",
    ReadWriteOtelEndpoint = "read-write:otel-endpoint",
    ReadMonitoring = "read:monitoring",
    ReadWriteIntegrationResource = "read-write:integration-resource",
}

export type Scopes = {
    added: Array<Added>;
    upgraded: Array<Upgraded>;
};

export type ScopesQueue = {
    scopes: Scopes;
    note: string;
    requestedAt: number;
    confirmedAt?: number | undefined;
};

export enum GetConfigurationsResponseBodyDisabledReason {
    DisabledByOwner = "disabled-by-owner",
    FeatureNotAvailable = "feature-not-available",
    DisabledByAdmin = "disabled-by-admin",
    OriginalOwnerLeftTheTeam = "original-owner-left-the-team",
}

/**
 * Defines the installation type. - 'external' integrations are installed via the existing integrations flow - 'marketplace' integrations are natively installed: - when accepting the TOS of a partner during the store creation process - if undefined, assume 'external'
 */
export enum InstallationType {
    Marketplace = "marketplace",
    External = "external",
}

export type GetConfigurationsResponseBody1 = {
    /**
     * A timestamp that tells you when the configuration was installed successfully
     */
    completedAt?: number | undefined;
    /**
     * A timestamp that tells you when the configuration was created
     */
    createdAt: number;
    /**
     * The unique identifier of the configuration
     */
    id: string;
    /**
     * The unique identifier of the app the configuration was created for
     */
    integrationId: string;
    /**
     * The user or team ID that owns the configuration
     */
    ownerId: string;
    /**
     * When a configuration is limited to access certain projects, this will contain each of the project ID it is allowed to access. If it is not defined, the configuration has full access.
     */
    projects?: Array<string> | undefined;
    /**
     * Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.
     */
    source?: GetConfigurationsResponseBodySource | undefined;
    removedLogDrainsAt?: number | undefined;
    removedProjectEnvsAt?: number | undefined;
    removedTokensAt?: number | undefined;
    removedWebhooksAt?: number | undefined;
    /**
     * The slug of the integration the configuration is created for.
     */
    slug: string;
    /**
     * When the configuration was created for a team, this will show the ID of the team.
     */
    teamId?: string | null | undefined;
    type: GetConfigurationsResponseBodyType;
    /**
     * A timestamp that tells you when the configuration was updated.
     */
    updatedAt: number;
    /**
     * The ID of the user that created the configuration.
     */
    userId: string;
    /**
     * The resources that are allowed to be accessed by the configuration.
     */
    scopes: Array<string>;
    scopesQueue?: Array<ScopesQueue> | undefined;
    /**
     * A timestamp that tells you when the configuration was disabled. Note: Configurations can be disabled when the associated user loses access to a team. They do not function during this time until the configuration is 'transferred', meaning the associated user is changed to one with access to the team.
     */
    disabledAt?: number | undefined;
    /**
     * A timestamp that tells you when the configuration was updated.
     */
    deletedAt?: number | null | undefined;
    disabledReason?: GetConfigurationsResponseBodyDisabledReason | undefined;
    /**
     * A timestamp that tells you when the configuration was migrated as part of the Northstar migration. In the future, if we allow integration configurations to be transferred between teams, this field should be cleared upon transfer.
     */
    northstarMigratedAt?: number | undefined;
    /**
     * Defines the installation type. - 'external' integrations are installed via the existing integrations flow - 'marketplace' integrations are natively installed: - when accepting the TOS of a partner during the store creation process - if undefined, assume 'external'
     */
    installationType?: InstallationType | undefined;
};

/**
 * The list of configurations for the authenticated user
 */
export type GetConfigurationsResponseBody =
    | GetConfigurationsResponseBody1
    | Array<GetConfigurationsResponseBody2>;

export type GetConfigurationsResponse = {
    httpMeta: components.HTTPMetadata;
    /**
     * The list of configurations for the authenticated user
     */
    oneOf?: GetConfigurationsResponseBody1 | Array<GetConfigurationsResponseBody2> | undefined;
};

/** @internal */
export namespace View$ {
    export const inboundSchema = z.nativeEnum(View);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace GetConfigurationsRequest$ {
    export const inboundSchema: z.ZodType<GetConfigurationsRequest, z.ZodTypeDef, unknown> = z
        .object({
            view: View$.inboundSchema,
            teamId: z.string().optional(),
            slug: z.string().optional(),
        })
        .transform((v) => {
            return {
                view: v.view,
                ...(v.teamId === undefined ? null : { teamId: v.teamId }),
                ...(v.slug === undefined ? null : { slug: v.slug }),
            };
        });

    export type Outbound = {
        view: string;
        teamId?: string | undefined;
        slug?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, GetConfigurationsRequest> = z
        .object({
            view: View$.outboundSchema,
            teamId: z.string().optional(),
            slug: z.string().optional(),
        })
        .transform((v) => {
            return {
                view: v.view,
                ...(v.teamId === undefined ? null : { teamId: v.teamId }),
                ...(v.slug === undefined ? null : { slug: v.slug }),
            };
        });
}

/** @internal */
export namespace Integration$ {
    export const inboundSchema: z.ZodType<Integration, z.ZodTypeDef, unknown> = z
        .object({
            name: z.string(),
            icon: z.string(),
            category: z.string(),
            isLegacy: z.boolean(),
            flags: z.array(z.string()).optional(),
            assignedBetaLabelAt: z.number().optional(),
        })
        .transform((v) => {
            return {
                name: v.name,
                icon: v.icon,
                category: v.category,
                isLegacy: v.isLegacy,
                ...(v.flags === undefined ? null : { flags: v.flags }),
                ...(v.assignedBetaLabelAt === undefined
                    ? null
                    : { assignedBetaLabelAt: v.assignedBetaLabelAt }),
            };
        });

    export type Outbound = {
        name: string;
        icon: string;
        category: string;
        isLegacy: boolean;
        flags?: Array<string> | undefined;
        assignedBetaLabelAt?: number | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Integration> = z
        .object({
            name: z.string(),
            icon: z.string(),
            category: z.string(),
            isLegacy: z.boolean(),
            flags: z.array(z.string()).optional(),
            assignedBetaLabelAt: z.number().optional(),
        })
        .transform((v) => {
            return {
                name: v.name,
                icon: v.icon,
                category: v.category,
                isLegacy: v.isLegacy,
                ...(v.flags === undefined ? null : { flags: v.flags }),
                ...(v.assignedBetaLabelAt === undefined
                    ? null
                    : { assignedBetaLabelAt: v.assignedBetaLabelAt }),
            };
        });
}

/** @internal */
export namespace GetConfigurationsResponseBodyIntegrationsSource$ {
    export const inboundSchema = z.nativeEnum(GetConfigurationsResponseBodyIntegrationsSource);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace GetConfigurationsResponseBodyIntegrationsType$ {
    export const inboundSchema = z.nativeEnum(GetConfigurationsResponseBodyIntegrationsType);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace ResponseBodyAdded$ {
    export const inboundSchema = z.nativeEnum(ResponseBodyAdded);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace ResponseBodyUpgraded$ {
    export const inboundSchema = z.nativeEnum(ResponseBodyUpgraded);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace ResponseBodyScopes$ {
    export const inboundSchema: z.ZodType<ResponseBodyScopes, z.ZodTypeDef, unknown> = z
        .object({
            added: z.array(ResponseBodyAdded$.inboundSchema),
            upgraded: z.array(ResponseBodyUpgraded$.inboundSchema),
        })
        .transform((v) => {
            return {
                added: v.added,
                upgraded: v.upgraded,
            };
        });

    export type Outbound = {
        added: Array<string>;
        upgraded: Array<string>;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ResponseBodyScopes> = z
        .object({
            added: z.array(ResponseBodyAdded$.outboundSchema),
            upgraded: z.array(ResponseBodyUpgraded$.outboundSchema),
        })
        .transform((v) => {
            return {
                added: v.added,
                upgraded: v.upgraded,
            };
        });
}

/** @internal */
export namespace ResponseBodyScopesQueue$ {
    export const inboundSchema: z.ZodType<ResponseBodyScopesQueue, z.ZodTypeDef, unknown> = z
        .object({
            scopes: z.lazy(() => ResponseBodyScopes$.inboundSchema),
            note: z.string(),
            requestedAt: z.number(),
            confirmedAt: z.number().optional(),
        })
        .transform((v) => {
            return {
                scopes: v.scopes,
                note: v.note,
                requestedAt: v.requestedAt,
                ...(v.confirmedAt === undefined ? null : { confirmedAt: v.confirmedAt }),
            };
        });

    export type Outbound = {
        scopes: ResponseBodyScopes$.Outbound;
        note: string;
        requestedAt: number;
        confirmedAt?: number | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ResponseBodyScopesQueue> = z
        .object({
            scopes: z.lazy(() => ResponseBodyScopes$.outboundSchema),
            note: z.string(),
            requestedAt: z.number(),
            confirmedAt: z.number().optional(),
        })
        .transform((v) => {
            return {
                scopes: v.scopes,
                note: v.note,
                requestedAt: v.requestedAt,
                ...(v.confirmedAt === undefined ? null : { confirmedAt: v.confirmedAt }),
            };
        });
}

/** @internal */
export namespace ResponseBodyDisabledReason$ {
    export const inboundSchema = z.nativeEnum(ResponseBodyDisabledReason);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace ResponseBodyInstallationType$ {
    export const inboundSchema = z.nativeEnum(ResponseBodyInstallationType);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace GetConfigurationsResponseBody2$ {
    export const inboundSchema: z.ZodType<GetConfigurationsResponseBody2, z.ZodTypeDef, unknown> = z
        .object({
            integration: z.lazy(() => Integration$.inboundSchema),
            completedAt: z.number().optional(),
            createdAt: z.number(),
            id: z.string(),
            integrationId: z.string(),
            ownerId: z.string(),
            projects: z.array(z.string()).optional(),
            source: GetConfigurationsResponseBodyIntegrationsSource$.inboundSchema.optional(),
            removedLogDrainsAt: z.number().optional(),
            removedProjectEnvsAt: z.number().optional(),
            removedTokensAt: z.number().optional(),
            removedWebhooksAt: z.number().optional(),
            slug: z.string(),
            teamId: z.nullable(z.string()).optional(),
            type: GetConfigurationsResponseBodyIntegrationsType$.inboundSchema,
            updatedAt: z.number(),
            userId: z.string(),
            scopes: z.array(z.string()),
            scopesQueue: z.array(z.lazy(() => ResponseBodyScopesQueue$.inboundSchema)).optional(),
            disabledAt: z.number().optional(),
            deletedAt: z.nullable(z.number()).optional(),
            disabledReason: ResponseBodyDisabledReason$.inboundSchema.optional(),
            northstarMigratedAt: z.number().optional(),
            installationType: ResponseBodyInstallationType$.inboundSchema.optional(),
        })
        .transform((v) => {
            return {
                integration: v.integration,
                ...(v.completedAt === undefined ? null : { completedAt: v.completedAt }),
                createdAt: v.createdAt,
                id: v.id,
                integrationId: v.integrationId,
                ownerId: v.ownerId,
                ...(v.projects === undefined ? null : { projects: v.projects }),
                ...(v.source === undefined ? null : { source: v.source }),
                ...(v.removedLogDrainsAt === undefined
                    ? null
                    : { removedLogDrainsAt: v.removedLogDrainsAt }),
                ...(v.removedProjectEnvsAt === undefined
                    ? null
                    : { removedProjectEnvsAt: v.removedProjectEnvsAt }),
                ...(v.removedTokensAt === undefined
                    ? null
                    : { removedTokensAt: v.removedTokensAt }),
                ...(v.removedWebhooksAt === undefined
                    ? null
                    : { removedWebhooksAt: v.removedWebhooksAt }),
                slug: v.slug,
                ...(v.teamId === undefined ? null : { teamId: v.teamId }),
                type: v.type,
                updatedAt: v.updatedAt,
                userId: v.userId,
                scopes: v.scopes,
                ...(v.scopesQueue === undefined ? null : { scopesQueue: v.scopesQueue }),
                ...(v.disabledAt === undefined ? null : { disabledAt: v.disabledAt }),
                ...(v.deletedAt === undefined ? null : { deletedAt: v.deletedAt }),
                ...(v.disabledReason === undefined ? null : { disabledReason: v.disabledReason }),
                ...(v.northstarMigratedAt === undefined
                    ? null
                    : { northstarMigratedAt: v.northstarMigratedAt }),
                ...(v.installationType === undefined
                    ? null
                    : { installationType: v.installationType }),
            };
        });

    export type Outbound = {
        integration: Integration$.Outbound;
        completedAt?: number | undefined;
        createdAt: number;
        id: string;
        integrationId: string;
        ownerId: string;
        projects?: Array<string> | undefined;
        source?: string | undefined;
        removedLogDrainsAt?: number | undefined;
        removedProjectEnvsAt?: number | undefined;
        removedTokensAt?: number | undefined;
        removedWebhooksAt?: number | undefined;
        slug: string;
        teamId?: string | null | undefined;
        type: string;
        updatedAt: number;
        userId: string;
        scopes: Array<string>;
        scopesQueue?: Array<ResponseBodyScopesQueue$.Outbound> | undefined;
        disabledAt?: number | undefined;
        deletedAt?: number | null | undefined;
        disabledReason?: string | undefined;
        northstarMigratedAt?: number | undefined;
        installationType?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, GetConfigurationsResponseBody2> =
        z
            .object({
                integration: z.lazy(() => Integration$.outboundSchema),
                completedAt: z.number().optional(),
                createdAt: z.number(),
                id: z.string(),
                integrationId: z.string(),
                ownerId: z.string(),
                projects: z.array(z.string()).optional(),
                source: GetConfigurationsResponseBodyIntegrationsSource$.outboundSchema.optional(),
                removedLogDrainsAt: z.number().optional(),
                removedProjectEnvsAt: z.number().optional(),
                removedTokensAt: z.number().optional(),
                removedWebhooksAt: z.number().optional(),
                slug: z.string(),
                teamId: z.nullable(z.string()).optional(),
                type: GetConfigurationsResponseBodyIntegrationsType$.outboundSchema,
                updatedAt: z.number(),
                userId: z.string(),
                scopes: z.array(z.string()),
                scopesQueue: z
                    .array(z.lazy(() => ResponseBodyScopesQueue$.outboundSchema))
                    .optional(),
                disabledAt: z.number().optional(),
                deletedAt: z.nullable(z.number()).optional(),
                disabledReason: ResponseBodyDisabledReason$.outboundSchema.optional(),
                northstarMigratedAt: z.number().optional(),
                installationType: ResponseBodyInstallationType$.outboundSchema.optional(),
            })
            .transform((v) => {
                return {
                    integration: v.integration,
                    ...(v.completedAt === undefined ? null : { completedAt: v.completedAt }),
                    createdAt: v.createdAt,
                    id: v.id,
                    integrationId: v.integrationId,
                    ownerId: v.ownerId,
                    ...(v.projects === undefined ? null : { projects: v.projects }),
                    ...(v.source === undefined ? null : { source: v.source }),
                    ...(v.removedLogDrainsAt === undefined
                        ? null
                        : { removedLogDrainsAt: v.removedLogDrainsAt }),
                    ...(v.removedProjectEnvsAt === undefined
                        ? null
                        : { removedProjectEnvsAt: v.removedProjectEnvsAt }),
                    ...(v.removedTokensAt === undefined
                        ? null
                        : { removedTokensAt: v.removedTokensAt }),
                    ...(v.removedWebhooksAt === undefined
                        ? null
                        : { removedWebhooksAt: v.removedWebhooksAt }),
                    slug: v.slug,
                    ...(v.teamId === undefined ? null : { teamId: v.teamId }),
                    type: v.type,
                    updatedAt: v.updatedAt,
                    userId: v.userId,
                    scopes: v.scopes,
                    ...(v.scopesQueue === undefined ? null : { scopesQueue: v.scopesQueue }),
                    ...(v.disabledAt === undefined ? null : { disabledAt: v.disabledAt }),
                    ...(v.deletedAt === undefined ? null : { deletedAt: v.deletedAt }),
                    ...(v.disabledReason === undefined
                        ? null
                        : { disabledReason: v.disabledReason }),
                    ...(v.northstarMigratedAt === undefined
                        ? null
                        : { northstarMigratedAt: v.northstarMigratedAt }),
                    ...(v.installationType === undefined
                        ? null
                        : { installationType: v.installationType }),
                };
            });
}

/** @internal */
export namespace GetConfigurationsResponseBodySource$ {
    export const inboundSchema = z.nativeEnum(GetConfigurationsResponseBodySource);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace GetConfigurationsResponseBodyType$ {
    export const inboundSchema = z.nativeEnum(GetConfigurationsResponseBodyType);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace Added$ {
    export const inboundSchema = z.nativeEnum(Added);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace Upgraded$ {
    export const inboundSchema = z.nativeEnum(Upgraded);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace Scopes$ {
    export const inboundSchema: z.ZodType<Scopes, z.ZodTypeDef, unknown> = z
        .object({
            added: z.array(Added$.inboundSchema),
            upgraded: z.array(Upgraded$.inboundSchema),
        })
        .transform((v) => {
            return {
                added: v.added,
                upgraded: v.upgraded,
            };
        });

    export type Outbound = {
        added: Array<string>;
        upgraded: Array<string>;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Scopes> = z
        .object({
            added: z.array(Added$.outboundSchema),
            upgraded: z.array(Upgraded$.outboundSchema),
        })
        .transform((v) => {
            return {
                added: v.added,
                upgraded: v.upgraded,
            };
        });
}

/** @internal */
export namespace ScopesQueue$ {
    export const inboundSchema: z.ZodType<ScopesQueue, z.ZodTypeDef, unknown> = z
        .object({
            scopes: z.lazy(() => Scopes$.inboundSchema),
            note: z.string(),
            requestedAt: z.number(),
            confirmedAt: z.number().optional(),
        })
        .transform((v) => {
            return {
                scopes: v.scopes,
                note: v.note,
                requestedAt: v.requestedAt,
                ...(v.confirmedAt === undefined ? null : { confirmedAt: v.confirmedAt }),
            };
        });

    export type Outbound = {
        scopes: Scopes$.Outbound;
        note: string;
        requestedAt: number;
        confirmedAt?: number | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ScopesQueue> = z
        .object({
            scopes: z.lazy(() => Scopes$.outboundSchema),
            note: z.string(),
            requestedAt: z.number(),
            confirmedAt: z.number().optional(),
        })
        .transform((v) => {
            return {
                scopes: v.scopes,
                note: v.note,
                requestedAt: v.requestedAt,
                ...(v.confirmedAt === undefined ? null : { confirmedAt: v.confirmedAt }),
            };
        });
}

/** @internal */
export namespace GetConfigurationsResponseBodyDisabledReason$ {
    export const inboundSchema = z.nativeEnum(GetConfigurationsResponseBodyDisabledReason);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace InstallationType$ {
    export const inboundSchema = z.nativeEnum(InstallationType);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace GetConfigurationsResponseBody1$ {
    export const inboundSchema: z.ZodType<GetConfigurationsResponseBody1, z.ZodTypeDef, unknown> = z
        .object({
            completedAt: z.number().optional(),
            createdAt: z.number(),
            id: z.string(),
            integrationId: z.string(),
            ownerId: z.string(),
            projects: z.array(z.string()).optional(),
            source: GetConfigurationsResponseBodySource$.inboundSchema.optional(),
            removedLogDrainsAt: z.number().optional(),
            removedProjectEnvsAt: z.number().optional(),
            removedTokensAt: z.number().optional(),
            removedWebhooksAt: z.number().optional(),
            slug: z.string(),
            teamId: z.nullable(z.string()).optional(),
            type: GetConfigurationsResponseBodyType$.inboundSchema,
            updatedAt: z.number(),
            userId: z.string(),
            scopes: z.array(z.string()),
            scopesQueue: z.array(z.lazy(() => ScopesQueue$.inboundSchema)).optional(),
            disabledAt: z.number().optional(),
            deletedAt: z.nullable(z.number()).optional(),
            disabledReason: GetConfigurationsResponseBodyDisabledReason$.inboundSchema.optional(),
            northstarMigratedAt: z.number().optional(),
            installationType: InstallationType$.inboundSchema.optional(),
        })
        .transform((v) => {
            return {
                ...(v.completedAt === undefined ? null : { completedAt: v.completedAt }),
                createdAt: v.createdAt,
                id: v.id,
                integrationId: v.integrationId,
                ownerId: v.ownerId,
                ...(v.projects === undefined ? null : { projects: v.projects }),
                ...(v.source === undefined ? null : { source: v.source }),
                ...(v.removedLogDrainsAt === undefined
                    ? null
                    : { removedLogDrainsAt: v.removedLogDrainsAt }),
                ...(v.removedProjectEnvsAt === undefined
                    ? null
                    : { removedProjectEnvsAt: v.removedProjectEnvsAt }),
                ...(v.removedTokensAt === undefined
                    ? null
                    : { removedTokensAt: v.removedTokensAt }),
                ...(v.removedWebhooksAt === undefined
                    ? null
                    : { removedWebhooksAt: v.removedWebhooksAt }),
                slug: v.slug,
                ...(v.teamId === undefined ? null : { teamId: v.teamId }),
                type: v.type,
                updatedAt: v.updatedAt,
                userId: v.userId,
                scopes: v.scopes,
                ...(v.scopesQueue === undefined ? null : { scopesQueue: v.scopesQueue }),
                ...(v.disabledAt === undefined ? null : { disabledAt: v.disabledAt }),
                ...(v.deletedAt === undefined ? null : { deletedAt: v.deletedAt }),
                ...(v.disabledReason === undefined ? null : { disabledReason: v.disabledReason }),
                ...(v.northstarMigratedAt === undefined
                    ? null
                    : { northstarMigratedAt: v.northstarMigratedAt }),
                ...(v.installationType === undefined
                    ? null
                    : { installationType: v.installationType }),
            };
        });

    export type Outbound = {
        completedAt?: number | undefined;
        createdAt: number;
        id: string;
        integrationId: string;
        ownerId: string;
        projects?: Array<string> | undefined;
        source?: string | undefined;
        removedLogDrainsAt?: number | undefined;
        removedProjectEnvsAt?: number | undefined;
        removedTokensAt?: number | undefined;
        removedWebhooksAt?: number | undefined;
        slug: string;
        teamId?: string | null | undefined;
        type: string;
        updatedAt: number;
        userId: string;
        scopes: Array<string>;
        scopesQueue?: Array<ScopesQueue$.Outbound> | undefined;
        disabledAt?: number | undefined;
        deletedAt?: number | null | undefined;
        disabledReason?: string | undefined;
        northstarMigratedAt?: number | undefined;
        installationType?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, GetConfigurationsResponseBody1> =
        z
            .object({
                completedAt: z.number().optional(),
                createdAt: z.number(),
                id: z.string(),
                integrationId: z.string(),
                ownerId: z.string(),
                projects: z.array(z.string()).optional(),
                source: GetConfigurationsResponseBodySource$.outboundSchema.optional(),
                removedLogDrainsAt: z.number().optional(),
                removedProjectEnvsAt: z.number().optional(),
                removedTokensAt: z.number().optional(),
                removedWebhooksAt: z.number().optional(),
                slug: z.string(),
                teamId: z.nullable(z.string()).optional(),
                type: GetConfigurationsResponseBodyType$.outboundSchema,
                updatedAt: z.number(),
                userId: z.string(),
                scopes: z.array(z.string()),
                scopesQueue: z.array(z.lazy(() => ScopesQueue$.outboundSchema)).optional(),
                disabledAt: z.number().optional(),
                deletedAt: z.nullable(z.number()).optional(),
                disabledReason:
                    GetConfigurationsResponseBodyDisabledReason$.outboundSchema.optional(),
                northstarMigratedAt: z.number().optional(),
                installationType: InstallationType$.outboundSchema.optional(),
            })
            .transform((v) => {
                return {
                    ...(v.completedAt === undefined ? null : { completedAt: v.completedAt }),
                    createdAt: v.createdAt,
                    id: v.id,
                    integrationId: v.integrationId,
                    ownerId: v.ownerId,
                    ...(v.projects === undefined ? null : { projects: v.projects }),
                    ...(v.source === undefined ? null : { source: v.source }),
                    ...(v.removedLogDrainsAt === undefined
                        ? null
                        : { removedLogDrainsAt: v.removedLogDrainsAt }),
                    ...(v.removedProjectEnvsAt === undefined
                        ? null
                        : { removedProjectEnvsAt: v.removedProjectEnvsAt }),
                    ...(v.removedTokensAt === undefined
                        ? null
                        : { removedTokensAt: v.removedTokensAt }),
                    ...(v.removedWebhooksAt === undefined
                        ? null
                        : { removedWebhooksAt: v.removedWebhooksAt }),
                    slug: v.slug,
                    ...(v.teamId === undefined ? null : { teamId: v.teamId }),
                    type: v.type,
                    updatedAt: v.updatedAt,
                    userId: v.userId,
                    scopes: v.scopes,
                    ...(v.scopesQueue === undefined ? null : { scopesQueue: v.scopesQueue }),
                    ...(v.disabledAt === undefined ? null : { disabledAt: v.disabledAt }),
                    ...(v.deletedAt === undefined ? null : { deletedAt: v.deletedAt }),
                    ...(v.disabledReason === undefined
                        ? null
                        : { disabledReason: v.disabledReason }),
                    ...(v.northstarMigratedAt === undefined
                        ? null
                        : { northstarMigratedAt: v.northstarMigratedAt }),
                    ...(v.installationType === undefined
                        ? null
                        : { installationType: v.installationType }),
                };
            });
}

/** @internal */
export namespace GetConfigurationsResponseBody$ {
    export const inboundSchema: z.ZodType<GetConfigurationsResponseBody, z.ZodTypeDef, unknown> =
        z.union([
            z.lazy(() => GetConfigurationsResponseBody1$.inboundSchema),
            z.array(z.lazy(() => GetConfigurationsResponseBody2$.inboundSchema)),
        ]);

    export type Outbound =
        | GetConfigurationsResponseBody1$.Outbound
        | Array<GetConfigurationsResponseBody2$.Outbound>;
    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, GetConfigurationsResponseBody> =
        z.union([
            z.lazy(() => GetConfigurationsResponseBody1$.outboundSchema),
            z.array(z.lazy(() => GetConfigurationsResponseBody2$.outboundSchema)),
        ]);
}

/** @internal */
export namespace GetConfigurationsResponse$ {
    export const inboundSchema: z.ZodType<GetConfigurationsResponse, z.ZodTypeDef, unknown> = z
        .object({
            HttpMeta: components.HTTPMetadata$.inboundSchema,
            oneOf: z
                .union([
                    z.lazy(() => GetConfigurationsResponseBody1$.inboundSchema),
                    z.array(z.lazy(() => GetConfigurationsResponseBody2$.inboundSchema)),
                ])
                .optional(),
        })
        .transform((v) => {
            return {
                httpMeta: v.HttpMeta,
                ...(v.oneOf === undefined ? null : { oneOf: v.oneOf }),
            };
        });

    export type Outbound = {
        HttpMeta: components.HTTPMetadata$.Outbound;
        oneOf?:
            | GetConfigurationsResponseBody1$.Outbound
            | Array<GetConfigurationsResponseBody2$.Outbound>
            | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, GetConfigurationsResponse> = z
        .object({
            httpMeta: components.HTTPMetadata$.outboundSchema,
            oneOf: z
                .union([
                    z.lazy(() => GetConfigurationsResponseBody1$.outboundSchema),
                    z.array(z.lazy(() => GetConfigurationsResponseBody2$.outboundSchema)),
                ])
                .optional(),
        })
        .transform((v) => {
            return {
                HttpMeta: v.httpMeta,
                ...(v.oneOf === undefined ? null : { oneOf: v.oneOf }),
            };
        });
}
