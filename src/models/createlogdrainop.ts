/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { remap as remap$ } from "../lib/primitives";
import * as z from "zod";

/**
 * The delivery log format
 */
export enum DeliveryFormat {
    Json = "json",
    Ndjson = "ndjson",
    Syslog = "syslog",
}

export enum Sources {
    Static = "static",
    Lambda = "lambda",
    Build = "build",
    Edge = "edge",
    External = "external",
}

export enum Environments {
    Preview = "preview",
    Production = "production",
}

export type CreateLogDrainRequestBody = {
    /**
     * The name of the log drain
     */
    name: string;
    projectIds?: Array<string> | undefined;
    /**
     * A secret to sign log drain notification headers so a consumer can verify their authenticity
     */
    secret?: string | undefined;
    /**
     * The delivery log format
     */
    deliveryFormat?: DeliveryFormat | undefined;
    /**
     * The url where you will receive logs. The protocol must be `https://` or `http://` when type is `json` and `ndjson`, and `syslog+tls:` or `syslog:` when the type is `syslog`.
     */
    url: string;
    sources?: Array<Sources> | undefined;
    /**
     * Headers to be sent together with the request
     */
    headers?: { [k: string]: string } | undefined;
    environments?: Array<Environments> | undefined;
};

export type CreateLogDrainRequest = {
    /**
     * The Team identifier to perform the request on behalf of.
     */
    teamId?: string | undefined;
    /**
     * The Team slug to perform the request on behalf of.
     */
    slug?: string | undefined;
    requestBody?: CreateLogDrainRequestBody | undefined;
};

/**
 * The delivery log format
 */
export enum CreateLogDrainDeliveryFormat {
    Json = "json",
    Ndjson = "ndjson",
    Syslog = "syslog",
}

/**
 * The sources from which logs are currently being delivered to this log drain.
 */
export enum CreateLogDrainSources {
    Build = "build",
    Edge = "edge",
    Lambda = "lambda",
    Static = "static",
    External = "external",
}

/**
 * Whether the log drain was created by an integration or by a user
 */
export enum CreateLogDrainCreatedFrom {
    SelfServed = "self-served",
    Integration = "integration",
}

/**
 * The environment of log drain
 */
export enum CreateLogDrainEnvironments {
    Production = "production",
    Preview = "preview",
}

/**
 * The log drain was successfully created
 */
export type CreateLogDrainResponseBody = {
    /**
     * The oauth2 client application id that created this log drain
     */
    clientId?: string | undefined;
    /**
     * The client configuration this log drain was created with
     */
    configurationId?: string | undefined;
    /**
     * A timestamp that tells you when the log drain was created
     */
    createdAt: number;
    /**
     * The unique identifier of the log drain. Always prefixed with `ld_`
     */
    id: string;
    /**
     * The delivery log format
     */
    deliveryFormat?: CreateLogDrainDeliveryFormat | undefined;
    /**
     * The name of the log drain
     */
    name: string;
    /**
     * The identifier of the team or user whose events will trigger the log drain
     */
    ownerId: string;
    projectId?: string | null | undefined;
    /**
     * The identifier of the projects this log drain is associated with
     */
    projectIds?: Array<string> | undefined;
    /**
     * The URL to call when logs are generated
     */
    url: string;
    /**
     * The sources from which logs are currently being delivered to this log drain.
     */
    sources?: Array<CreateLogDrainSources> | undefined;
    /**
     * Whether the log drain was created by an integration or by a user
     */
    createdFrom?: CreateLogDrainCreatedFrom | undefined;
    /**
     * The headers to send with the request
     */
    headers?: { [k: string]: string } | undefined;
    /**
     * The environment of log drain
     */
    environments: Array<CreateLogDrainEnvironments>;
    /**
     * The branch regexp of log drain
     */
    branch?: string | undefined;
    /**
     * The sampling rate of log drain
     */
    samplingRate?: number | undefined;
};

/** @internal */
export namespace DeliveryFormat$ {
    export const inboundSchema = z.nativeEnum(DeliveryFormat);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace Sources$ {
    export const inboundSchema = z.nativeEnum(Sources);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace Environments$ {
    export const inboundSchema = z.nativeEnum(Environments);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace CreateLogDrainRequestBody$ {
    export const inboundSchema: z.ZodType<CreateLogDrainRequestBody, z.ZodTypeDef, unknown> =
        z.object({
            name: z.string(),
            projectIds: z.array(z.string()).optional(),
            secret: z.string().optional(),
            deliveryFormat: DeliveryFormat$.inboundSchema.optional(),
            url: z.string(),
            sources: z.array(Sources$.inboundSchema).optional(),
            headers: z.record(z.string()).optional(),
            environments: z.array(Environments$.inboundSchema).optional(),
        });

    export type Outbound = {
        name: string;
        projectIds?: Array<string> | undefined;
        secret?: string | undefined;
        deliveryFormat?: string | undefined;
        url: string;
        sources?: Array<string> | undefined;
        headers?: { [k: string]: string } | undefined;
        environments?: Array<string> | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, CreateLogDrainRequestBody> =
        z.object({
            name: z.string(),
            projectIds: z.array(z.string()).optional(),
            secret: z.string().optional(),
            deliveryFormat: DeliveryFormat$.outboundSchema.optional(),
            url: z.string(),
            sources: z.array(Sources$.outboundSchema).optional(),
            headers: z.record(z.string()).optional(),
            environments: z.array(Environments$.outboundSchema).optional(),
        });
}

/** @internal */
export namespace CreateLogDrainRequest$ {
    export const inboundSchema: z.ZodType<CreateLogDrainRequest, z.ZodTypeDef, unknown> = z
        .object({
            teamId: z.string().optional(),
            slug: z.string().optional(),
            RequestBody: z.lazy(() => CreateLogDrainRequestBody$.inboundSchema).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                RequestBody: "requestBody",
            });
        });

    export type Outbound = {
        teamId?: string | undefined;
        slug?: string | undefined;
        RequestBody?: CreateLogDrainRequestBody$.Outbound | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, CreateLogDrainRequest> = z
        .object({
            teamId: z.string().optional(),
            slug: z.string().optional(),
            requestBody: z.lazy(() => CreateLogDrainRequestBody$.outboundSchema).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                requestBody: "RequestBody",
            });
        });
}

/** @internal */
export namespace CreateLogDrainDeliveryFormat$ {
    export const inboundSchema = z.nativeEnum(CreateLogDrainDeliveryFormat);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace CreateLogDrainSources$ {
    export const inboundSchema = z.nativeEnum(CreateLogDrainSources);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace CreateLogDrainCreatedFrom$ {
    export const inboundSchema = z.nativeEnum(CreateLogDrainCreatedFrom);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace CreateLogDrainEnvironments$ {
    export const inboundSchema = z.nativeEnum(CreateLogDrainEnvironments);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace CreateLogDrainResponseBody$ {
    export const inboundSchema: z.ZodType<CreateLogDrainResponseBody, z.ZodTypeDef, unknown> =
        z.object({
            clientId: z.string().optional(),
            configurationId: z.string().optional(),
            createdAt: z.number(),
            id: z.string(),
            deliveryFormat: CreateLogDrainDeliveryFormat$.inboundSchema.optional(),
            name: z.string(),
            ownerId: z.string(),
            projectId: z.nullable(z.string()).optional(),
            projectIds: z.array(z.string()).optional(),
            url: z.string(),
            sources: z.array(CreateLogDrainSources$.inboundSchema).optional(),
            createdFrom: CreateLogDrainCreatedFrom$.inboundSchema.optional(),
            headers: z.record(z.string()).optional(),
            environments: z.array(CreateLogDrainEnvironments$.inboundSchema),
            branch: z.string().optional(),
            samplingRate: z.number().optional(),
        });

    export type Outbound = {
        clientId?: string | undefined;
        configurationId?: string | undefined;
        createdAt: number;
        id: string;
        deliveryFormat?: string | undefined;
        name: string;
        ownerId: string;
        projectId?: string | null | undefined;
        projectIds?: Array<string> | undefined;
        url: string;
        sources?: Array<string> | undefined;
        createdFrom?: string | undefined;
        headers?: { [k: string]: string } | undefined;
        environments: Array<string>;
        branch?: string | undefined;
        samplingRate?: number | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, CreateLogDrainResponseBody> =
        z.object({
            clientId: z.string().optional(),
            configurationId: z.string().optional(),
            createdAt: z.number(),
            id: z.string(),
            deliveryFormat: CreateLogDrainDeliveryFormat$.outboundSchema.optional(),
            name: z.string(),
            ownerId: z.string(),
            projectId: z.nullable(z.string()).optional(),
            projectIds: z.array(z.string()).optional(),
            url: z.string(),
            sources: z.array(CreateLogDrainSources$.outboundSchema).optional(),
            createdFrom: CreateLogDrainCreatedFrom$.outboundSchema.optional(),
            headers: z.record(z.string()).optional(),
            environments: z.array(CreateLogDrainEnvironments$.outboundSchema),
            branch: z.string().optional(),
            samplingRate: z.number().optional(),
        });
}
