/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as z from "zod";

export enum View {
    Account = "account",
    Project = "project",
}

export type GetConfigurationsRequest = {
    view: View;
    /**
     * The Team identifier to perform the request on behalf of.
     */
    teamId?: string | undefined;
    /**
     * The Team slug to perform the request on behalf of.
     */
    slug?: string | undefined;
};

export type Integration = {
    name: string;
    icon: string;
    category: string;
    isLegacy: boolean;
    flags?: Array<string> | undefined;
    assignedBetaLabelAt?: number | undefined;
};

/**
 * Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.
 */
export enum GetConfigurationsResponseBodyIntegrationsSource {
    Marketplace = "marketplace",
    DeployButton = "deploy-button",
    External = "external",
}

export enum GetConfigurationsResponseBodyIntegrationsType {
    IntegrationConfiguration = "integration-configuration",
}

export enum ResponseBodyAdded {
    ReadIntegrationConfiguration = "read:integration-configuration",
    ReadWriteIntegrationConfiguration = "read-write:integration-configuration",
    ReadDeployment = "read:deployment",
    ReadWriteDeployment = "read-write:deployment",
    ReadWriteDeploymentCheck = "read-write:deployment-check",
    ReadProject = "read:project",
    ReadWriteProject = "read-write:project",
    ReadWriteProjectEnvVars = "read-write:project-env-vars",
    ReadWriteGlobalProjectEnvVars = "read-write:global-project-env-vars",
    ReadTeam = "read:team",
    ReadUser = "read:user",
    ReadWriteLogDrain = "read-write:log-drain",
    ReadDomain = "read:domain",
    ReadWriteDomain = "read-write:domain",
    ReadWriteEdgeConfig = "read-write:edge-config",
    ReadWriteOtelEndpoint = "read-write:otel-endpoint",
    ReadMonitoring = "read:monitoring",
    ReadWriteIntegrationResource = "read-write:integration-resource",
}

export enum ResponseBodyUpgraded {
    ReadIntegrationConfiguration = "read:integration-configuration",
    ReadWriteIntegrationConfiguration = "read-write:integration-configuration",
    ReadDeployment = "read:deployment",
    ReadWriteDeployment = "read-write:deployment",
    ReadWriteDeploymentCheck = "read-write:deployment-check",
    ReadProject = "read:project",
    ReadWriteProject = "read-write:project",
    ReadWriteProjectEnvVars = "read-write:project-env-vars",
    ReadWriteGlobalProjectEnvVars = "read-write:global-project-env-vars",
    ReadTeam = "read:team",
    ReadUser = "read:user",
    ReadWriteLogDrain = "read-write:log-drain",
    ReadDomain = "read:domain",
    ReadWriteDomain = "read-write:domain",
    ReadWriteEdgeConfig = "read-write:edge-config",
    ReadWriteOtelEndpoint = "read-write:otel-endpoint",
    ReadMonitoring = "read:monitoring",
    ReadWriteIntegrationResource = "read-write:integration-resource",
}

export type ResponseBodyScopes = {
    added: Array<ResponseBodyAdded>;
    upgraded: Array<ResponseBodyUpgraded>;
};

export type ResponseBodyScopesQueue = {
    scopes: ResponseBodyScopes;
    note: string;
    requestedAt: number;
    confirmedAt?: number | undefined;
};

export enum ResponseBodyDisabledReason {
    DisabledByOwner = "disabled-by-owner",
    FeatureNotAvailable = "feature-not-available",
    DisabledByAdmin = "disabled-by-admin",
    OriginalOwnerLeftTheTeam = "original-owner-left-the-team",
}

/**
 * Defines the installation type. - 'external' integrations are installed via the existing integrations flow - 'marketplace' integrations are natively installed: - when accepting the TOS of a partner during the store creation process - if undefined, assume 'external'
 */
export enum ResponseBodyInstallationType {
    Marketplace = "marketplace",
    External = "external",
}

export type GetConfigurationsResponseBody2 = {
    integration: Integration;
    /**
     * A timestamp that tells you when the configuration was installed successfully
     */
    completedAt?: number | undefined;
    /**
     * A timestamp that tells you when the configuration was created
     */
    createdAt: number;
    /**
     * The unique identifier of the configuration
     */
    id: string;
    /**
     * The unique identifier of the app the configuration was created for
     */
    integrationId: string;
    /**
     * The user or team ID that owns the configuration
     */
    ownerId: string;
    /**
     * When a configuration is limited to access certain projects, this will contain each of the project ID it is allowed to access. If it is not defined, the configuration has full access.
     */
    projects?: Array<string> | undefined;
    /**
     * Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.
     */
    source?: GetConfigurationsResponseBodyIntegrationsSource | undefined;
    removedLogDrainsAt?: number | undefined;
    removedProjectEnvsAt?: number | undefined;
    removedTokensAt?: number | undefined;
    removedWebhooksAt?: number | undefined;
    /**
     * The slug of the integration the configuration is created for.
     */
    slug: string;
    /**
     * When the configuration was created for a team, this will show the ID of the team.
     */
    teamId?: string | null | undefined;
    type: GetConfigurationsResponseBodyIntegrationsType;
    /**
     * A timestamp that tells you when the configuration was updated.
     */
    updatedAt: number;
    /**
     * The ID of the user that created the configuration.
     */
    userId: string;
    /**
     * The resources that are allowed to be accessed by the configuration.
     */
    scopes: Array<string>;
    scopesQueue?: Array<ResponseBodyScopesQueue> | undefined;
    /**
     * A timestamp that tells you when the configuration was disabled. Note: Configurations can be disabled when the associated user loses access to a team. They do not function during this time until the configuration is 'transferred', meaning the associated user is changed to one with access to the team.
     */
    disabledAt?: number | undefined;
    /**
     * A timestamp that tells you when the configuration was updated.
     */
    deletedAt?: number | null | undefined;
    disabledReason?: ResponseBodyDisabledReason | undefined;
    /**
     * A timestamp that tells you when the configuration was migrated as part of the Northstar migration. In the future, if we allow integration configurations to be transferred between teams, this field should be cleared upon transfer.
     */
    northstarMigratedAt?: number | undefined;
    /**
     * Defines the installation type. - 'external' integrations are installed via the existing integrations flow - 'marketplace' integrations are natively installed: - when accepting the TOS of a partner during the store creation process - if undefined, assume 'external'
     */
    installationType?: ResponseBodyInstallationType | undefined;
};

/**
 * Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.
 */
export enum GetConfigurationsResponseBodySource {
    Marketplace = "marketplace",
    DeployButton = "deploy-button",
    External = "external",
}

export enum GetConfigurationsResponseBodyType {
    IntegrationConfiguration = "integration-configuration",
}

export enum Added {
    ReadIntegrationConfiguration = "read:integration-configuration",
    ReadWriteIntegrationConfiguration = "read-write:integration-configuration",
    ReadDeployment = "read:deployment",
    ReadWriteDeployment = "read-write:deployment",
    ReadWriteDeploymentCheck = "read-write:deployment-check",
    ReadProject = "read:project",
    ReadWriteProject = "read-write:project",
    ReadWriteProjectEnvVars = "read-write:project-env-vars",
    ReadWriteGlobalProjectEnvVars = "read-write:global-project-env-vars",
    ReadTeam = "read:team",
    ReadUser = "read:user",
    ReadWriteLogDrain = "read-write:log-drain",
    ReadDomain = "read:domain",
    ReadWriteDomain = "read-write:domain",
    ReadWriteEdgeConfig = "read-write:edge-config",
    ReadWriteOtelEndpoint = "read-write:otel-endpoint",
    ReadMonitoring = "read:monitoring",
    ReadWriteIntegrationResource = "read-write:integration-resource",
}

export enum Upgraded {
    ReadIntegrationConfiguration = "read:integration-configuration",
    ReadWriteIntegrationConfiguration = "read-write:integration-configuration",
    ReadDeployment = "read:deployment",
    ReadWriteDeployment = "read-write:deployment",
    ReadWriteDeploymentCheck = "read-write:deployment-check",
    ReadProject = "read:project",
    ReadWriteProject = "read-write:project",
    ReadWriteProjectEnvVars = "read-write:project-env-vars",
    ReadWriteGlobalProjectEnvVars = "read-write:global-project-env-vars",
    ReadTeam = "read:team",
    ReadUser = "read:user",
    ReadWriteLogDrain = "read-write:log-drain",
    ReadDomain = "read:domain",
    ReadWriteDomain = "read-write:domain",
    ReadWriteEdgeConfig = "read-write:edge-config",
    ReadWriteOtelEndpoint = "read-write:otel-endpoint",
    ReadMonitoring = "read:monitoring",
    ReadWriteIntegrationResource = "read-write:integration-resource",
}

export type GetConfigurationsResponseBodyScopes = {
    added: Array<Added>;
    upgraded: Array<Upgraded>;
};

export type ScopesQueue = {
    scopes: GetConfigurationsResponseBodyScopes;
    note: string;
    requestedAt: number;
    confirmedAt?: number | undefined;
};

export enum GetConfigurationsResponseBodyDisabledReason {
    DisabledByOwner = "disabled-by-owner",
    FeatureNotAvailable = "feature-not-available",
    DisabledByAdmin = "disabled-by-admin",
    OriginalOwnerLeftTheTeam = "original-owner-left-the-team",
}

/**
 * Defines the installation type. - 'external' integrations are installed via the existing integrations flow - 'marketplace' integrations are natively installed: - when accepting the TOS of a partner during the store creation process - if undefined, assume 'external'
 */
export enum InstallationType {
    Marketplace = "marketplace",
    External = "external",
}

export type GetConfigurationsResponseBody1 = {
    /**
     * A timestamp that tells you when the configuration was installed successfully
     */
    completedAt?: number | undefined;
    /**
     * A timestamp that tells you when the configuration was created
     */
    createdAt: number;
    /**
     * The unique identifier of the configuration
     */
    id: string;
    /**
     * The unique identifier of the app the configuration was created for
     */
    integrationId: string;
    /**
     * The user or team ID that owns the configuration
     */
    ownerId: string;
    /**
     * When a configuration is limited to access certain projects, this will contain each of the project ID it is allowed to access. If it is not defined, the configuration has full access.
     */
    projects?: Array<string> | undefined;
    /**
     * Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.
     */
    source?: GetConfigurationsResponseBodySource | undefined;
    removedLogDrainsAt?: number | undefined;
    removedProjectEnvsAt?: number | undefined;
    removedTokensAt?: number | undefined;
    removedWebhooksAt?: number | undefined;
    /**
     * The slug of the integration the configuration is created for.
     */
    slug: string;
    /**
     * When the configuration was created for a team, this will show the ID of the team.
     */
    teamId?: string | null | undefined;
    type: GetConfigurationsResponseBodyType;
    /**
     * A timestamp that tells you when the configuration was updated.
     */
    updatedAt: number;
    /**
     * The ID of the user that created the configuration.
     */
    userId: string;
    /**
     * The resources that are allowed to be accessed by the configuration.
     */
    scopes: Array<string>;
    scopesQueue?: Array<ScopesQueue> | undefined;
    /**
     * A timestamp that tells you when the configuration was disabled. Note: Configurations can be disabled when the associated user loses access to a team. They do not function during this time until the configuration is 'transferred', meaning the associated user is changed to one with access to the team.
     */
    disabledAt?: number | undefined;
    /**
     * A timestamp that tells you when the configuration was updated.
     */
    deletedAt?: number | null | undefined;
    disabledReason?: GetConfigurationsResponseBodyDisabledReason | undefined;
    /**
     * A timestamp that tells you when the configuration was migrated as part of the Northstar migration. In the future, if we allow integration configurations to be transferred between teams, this field should be cleared upon transfer.
     */
    northstarMigratedAt?: number | undefined;
    /**
     * Defines the installation type. - 'external' integrations are installed via the existing integrations flow - 'marketplace' integrations are natively installed: - when accepting the TOS of a partner during the store creation process - if undefined, assume 'external'
     */
    installationType?: InstallationType | undefined;
};

/**
 * The list of configurations for the authenticated user
 */
export type GetConfigurationsResponseBody =
    | GetConfigurationsResponseBody1
    | Array<GetConfigurationsResponseBody2>;

/** @internal */
export namespace View$ {
    export const inboundSchema: z.ZodNativeEnum<typeof View> = z.nativeEnum(View);
    export const outboundSchema: z.ZodNativeEnum<typeof View> = inboundSchema;
}

/** @internal */
export namespace GetConfigurationsRequest$ {
    export const inboundSchema: z.ZodType<GetConfigurationsRequest, z.ZodTypeDef, unknown> =
        z.object({
            view: View$.inboundSchema,
            teamId: z.string().optional(),
            slug: z.string().optional(),
        });

    export type Outbound = {
        view: string;
        teamId?: string | undefined;
        slug?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, GetConfigurationsRequest> =
        z.object({
            view: View$.outboundSchema,
            teamId: z.string().optional(),
            slug: z.string().optional(),
        });
}

/** @internal */
export namespace Integration$ {
    export const inboundSchema: z.ZodType<Integration, z.ZodTypeDef, unknown> = z.object({
        name: z.string(),
        icon: z.string(),
        category: z.string(),
        isLegacy: z.boolean(),
        flags: z.array(z.string()).optional(),
        assignedBetaLabelAt: z.number().optional(),
    });

    export type Outbound = {
        name: string;
        icon: string;
        category: string;
        isLegacy: boolean;
        flags?: Array<string> | undefined;
        assignedBetaLabelAt?: number | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Integration> = z.object({
        name: z.string(),
        icon: z.string(),
        category: z.string(),
        isLegacy: z.boolean(),
        flags: z.array(z.string()).optional(),
        assignedBetaLabelAt: z.number().optional(),
    });
}

/** @internal */
export namespace GetConfigurationsResponseBodyIntegrationsSource$ {
    export const inboundSchema: z.ZodNativeEnum<
        typeof GetConfigurationsResponseBodyIntegrationsSource
    > = z.nativeEnum(GetConfigurationsResponseBodyIntegrationsSource);
    export const outboundSchema: z.ZodNativeEnum<
        typeof GetConfigurationsResponseBodyIntegrationsSource
    > = inboundSchema;
}

/** @internal */
export namespace GetConfigurationsResponseBodyIntegrationsType$ {
    export const inboundSchema: z.ZodNativeEnum<
        typeof GetConfigurationsResponseBodyIntegrationsType
    > = z.nativeEnum(GetConfigurationsResponseBodyIntegrationsType);
    export const outboundSchema: z.ZodNativeEnum<
        typeof GetConfigurationsResponseBodyIntegrationsType
    > = inboundSchema;
}

/** @internal */
export namespace ResponseBodyAdded$ {
    export const inboundSchema: z.ZodNativeEnum<typeof ResponseBodyAdded> =
        z.nativeEnum(ResponseBodyAdded);
    export const outboundSchema: z.ZodNativeEnum<typeof ResponseBodyAdded> = inboundSchema;
}

/** @internal */
export namespace ResponseBodyUpgraded$ {
    export const inboundSchema: z.ZodNativeEnum<typeof ResponseBodyUpgraded> =
        z.nativeEnum(ResponseBodyUpgraded);
    export const outboundSchema: z.ZodNativeEnum<typeof ResponseBodyUpgraded> = inboundSchema;
}

/** @internal */
export namespace ResponseBodyScopes$ {
    export const inboundSchema: z.ZodType<ResponseBodyScopes, z.ZodTypeDef, unknown> = z.object({
        added: z.array(ResponseBodyAdded$.inboundSchema),
        upgraded: z.array(ResponseBodyUpgraded$.inboundSchema),
    });

    export type Outbound = {
        added: Array<string>;
        upgraded: Array<string>;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ResponseBodyScopes> = z.object({
        added: z.array(ResponseBodyAdded$.outboundSchema),
        upgraded: z.array(ResponseBodyUpgraded$.outboundSchema),
    });
}

/** @internal */
export namespace ResponseBodyScopesQueue$ {
    export const inboundSchema: z.ZodType<ResponseBodyScopesQueue, z.ZodTypeDef, unknown> =
        z.object({
            scopes: z.lazy(() => ResponseBodyScopes$.inboundSchema),
            note: z.string(),
            requestedAt: z.number(),
            confirmedAt: z.number().optional(),
        });

    export type Outbound = {
        scopes: ResponseBodyScopes$.Outbound;
        note: string;
        requestedAt: number;
        confirmedAt?: number | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ResponseBodyScopesQueue> =
        z.object({
            scopes: z.lazy(() => ResponseBodyScopes$.outboundSchema),
            note: z.string(),
            requestedAt: z.number(),
            confirmedAt: z.number().optional(),
        });
}

/** @internal */
export namespace ResponseBodyDisabledReason$ {
    export const inboundSchema: z.ZodNativeEnum<typeof ResponseBodyDisabledReason> = z.nativeEnum(
        ResponseBodyDisabledReason
    );
    export const outboundSchema: z.ZodNativeEnum<typeof ResponseBodyDisabledReason> = inboundSchema;
}

/** @internal */
export namespace ResponseBodyInstallationType$ {
    export const inboundSchema: z.ZodNativeEnum<typeof ResponseBodyInstallationType> = z.nativeEnum(
        ResponseBodyInstallationType
    );
    export const outboundSchema: z.ZodNativeEnum<typeof ResponseBodyInstallationType> =
        inboundSchema;
}

/** @internal */
export namespace GetConfigurationsResponseBody2$ {
    export const inboundSchema: z.ZodType<GetConfigurationsResponseBody2, z.ZodTypeDef, unknown> =
        z.object({
            integration: z.lazy(() => Integration$.inboundSchema),
            completedAt: z.number().optional(),
            createdAt: z.number(),
            id: z.string(),
            integrationId: z.string(),
            ownerId: z.string(),
            projects: z.array(z.string()).optional(),
            source: GetConfigurationsResponseBodyIntegrationsSource$.inboundSchema.optional(),
            removedLogDrainsAt: z.number().optional(),
            removedProjectEnvsAt: z.number().optional(),
            removedTokensAt: z.number().optional(),
            removedWebhooksAt: z.number().optional(),
            slug: z.string(),
            teamId: z.nullable(z.string()).optional(),
            type: GetConfigurationsResponseBodyIntegrationsType$.inboundSchema,
            updatedAt: z.number(),
            userId: z.string(),
            scopes: z.array(z.string()),
            scopesQueue: z.array(z.lazy(() => ResponseBodyScopesQueue$.inboundSchema)).optional(),
            disabledAt: z.number().optional(),
            deletedAt: z.nullable(z.number()).optional(),
            disabledReason: ResponseBodyDisabledReason$.inboundSchema.optional(),
            northstarMigratedAt: z.number().optional(),
            installationType: ResponseBodyInstallationType$.inboundSchema.optional(),
        });

    export type Outbound = {
        integration: Integration$.Outbound;
        completedAt?: number | undefined;
        createdAt: number;
        id: string;
        integrationId: string;
        ownerId: string;
        projects?: Array<string> | undefined;
        source?: string | undefined;
        removedLogDrainsAt?: number | undefined;
        removedProjectEnvsAt?: number | undefined;
        removedTokensAt?: number | undefined;
        removedWebhooksAt?: number | undefined;
        slug: string;
        teamId?: string | null | undefined;
        type: string;
        updatedAt: number;
        userId: string;
        scopes: Array<string>;
        scopesQueue?: Array<ResponseBodyScopesQueue$.Outbound> | undefined;
        disabledAt?: number | undefined;
        deletedAt?: number | null | undefined;
        disabledReason?: string | undefined;
        northstarMigratedAt?: number | undefined;
        installationType?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, GetConfigurationsResponseBody2> =
        z.object({
            integration: z.lazy(() => Integration$.outboundSchema),
            completedAt: z.number().optional(),
            createdAt: z.number(),
            id: z.string(),
            integrationId: z.string(),
            ownerId: z.string(),
            projects: z.array(z.string()).optional(),
            source: GetConfigurationsResponseBodyIntegrationsSource$.outboundSchema.optional(),
            removedLogDrainsAt: z.number().optional(),
            removedProjectEnvsAt: z.number().optional(),
            removedTokensAt: z.number().optional(),
            removedWebhooksAt: z.number().optional(),
            slug: z.string(),
            teamId: z.nullable(z.string()).optional(),
            type: GetConfigurationsResponseBodyIntegrationsType$.outboundSchema,
            updatedAt: z.number(),
            userId: z.string(),
            scopes: z.array(z.string()),
            scopesQueue: z.array(z.lazy(() => ResponseBodyScopesQueue$.outboundSchema)).optional(),
            disabledAt: z.number().optional(),
            deletedAt: z.nullable(z.number()).optional(),
            disabledReason: ResponseBodyDisabledReason$.outboundSchema.optional(),
            northstarMigratedAt: z.number().optional(),
            installationType: ResponseBodyInstallationType$.outboundSchema.optional(),
        });
}

/** @internal */
export namespace GetConfigurationsResponseBodySource$ {
    export const inboundSchema: z.ZodNativeEnum<typeof GetConfigurationsResponseBodySource> =
        z.nativeEnum(GetConfigurationsResponseBodySource);
    export const outboundSchema: z.ZodNativeEnum<typeof GetConfigurationsResponseBodySource> =
        inboundSchema;
}

/** @internal */
export namespace GetConfigurationsResponseBodyType$ {
    export const inboundSchema: z.ZodNativeEnum<typeof GetConfigurationsResponseBodyType> =
        z.nativeEnum(GetConfigurationsResponseBodyType);
    export const outboundSchema: z.ZodNativeEnum<typeof GetConfigurationsResponseBodyType> =
        inboundSchema;
}

/** @internal */
export namespace Added$ {
    export const inboundSchema: z.ZodNativeEnum<typeof Added> = z.nativeEnum(Added);
    export const outboundSchema: z.ZodNativeEnum<typeof Added> = inboundSchema;
}

/** @internal */
export namespace Upgraded$ {
    export const inboundSchema: z.ZodNativeEnum<typeof Upgraded> = z.nativeEnum(Upgraded);
    export const outboundSchema: z.ZodNativeEnum<typeof Upgraded> = inboundSchema;
}

/** @internal */
export namespace GetConfigurationsResponseBodyScopes$ {
    export const inboundSchema: z.ZodType<
        GetConfigurationsResponseBodyScopes,
        z.ZodTypeDef,
        unknown
    > = z.object({
        added: z.array(Added$.inboundSchema),
        upgraded: z.array(Upgraded$.inboundSchema),
    });

    export type Outbound = {
        added: Array<string>;
        upgraded: Array<string>;
    };

    export const outboundSchema: z.ZodType<
        Outbound,
        z.ZodTypeDef,
        GetConfigurationsResponseBodyScopes
    > = z.object({
        added: z.array(Added$.outboundSchema),
        upgraded: z.array(Upgraded$.outboundSchema),
    });
}

/** @internal */
export namespace ScopesQueue$ {
    export const inboundSchema: z.ZodType<ScopesQueue, z.ZodTypeDef, unknown> = z.object({
        scopes: z.lazy(() => GetConfigurationsResponseBodyScopes$.inboundSchema),
        note: z.string(),
        requestedAt: z.number(),
        confirmedAt: z.number().optional(),
    });

    export type Outbound = {
        scopes: GetConfigurationsResponseBodyScopes$.Outbound;
        note: string;
        requestedAt: number;
        confirmedAt?: number | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ScopesQueue> = z.object({
        scopes: z.lazy(() => GetConfigurationsResponseBodyScopes$.outboundSchema),
        note: z.string(),
        requestedAt: z.number(),
        confirmedAt: z.number().optional(),
    });
}

/** @internal */
export namespace GetConfigurationsResponseBodyDisabledReason$ {
    export const inboundSchema: z.ZodNativeEnum<
        typeof GetConfigurationsResponseBodyDisabledReason
    > = z.nativeEnum(GetConfigurationsResponseBodyDisabledReason);
    export const outboundSchema: z.ZodNativeEnum<
        typeof GetConfigurationsResponseBodyDisabledReason
    > = inboundSchema;
}

/** @internal */
export namespace InstallationType$ {
    export const inboundSchema: z.ZodNativeEnum<typeof InstallationType> =
        z.nativeEnum(InstallationType);
    export const outboundSchema: z.ZodNativeEnum<typeof InstallationType> = inboundSchema;
}

/** @internal */
export namespace GetConfigurationsResponseBody1$ {
    export const inboundSchema: z.ZodType<GetConfigurationsResponseBody1, z.ZodTypeDef, unknown> =
        z.object({
            completedAt: z.number().optional(),
            createdAt: z.number(),
            id: z.string(),
            integrationId: z.string(),
            ownerId: z.string(),
            projects: z.array(z.string()).optional(),
            source: GetConfigurationsResponseBodySource$.inboundSchema.optional(),
            removedLogDrainsAt: z.number().optional(),
            removedProjectEnvsAt: z.number().optional(),
            removedTokensAt: z.number().optional(),
            removedWebhooksAt: z.number().optional(),
            slug: z.string(),
            teamId: z.nullable(z.string()).optional(),
            type: GetConfigurationsResponseBodyType$.inboundSchema,
            updatedAt: z.number(),
            userId: z.string(),
            scopes: z.array(z.string()),
            scopesQueue: z.array(z.lazy(() => ScopesQueue$.inboundSchema)).optional(),
            disabledAt: z.number().optional(),
            deletedAt: z.nullable(z.number()).optional(),
            disabledReason: GetConfigurationsResponseBodyDisabledReason$.inboundSchema.optional(),
            northstarMigratedAt: z.number().optional(),
            installationType: InstallationType$.inboundSchema.optional(),
        });

    export type Outbound = {
        completedAt?: number | undefined;
        createdAt: number;
        id: string;
        integrationId: string;
        ownerId: string;
        projects?: Array<string> | undefined;
        source?: string | undefined;
        removedLogDrainsAt?: number | undefined;
        removedProjectEnvsAt?: number | undefined;
        removedTokensAt?: number | undefined;
        removedWebhooksAt?: number | undefined;
        slug: string;
        teamId?: string | null | undefined;
        type: string;
        updatedAt: number;
        userId: string;
        scopes: Array<string>;
        scopesQueue?: Array<ScopesQueue$.Outbound> | undefined;
        disabledAt?: number | undefined;
        deletedAt?: number | null | undefined;
        disabledReason?: string | undefined;
        northstarMigratedAt?: number | undefined;
        installationType?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, GetConfigurationsResponseBody1> =
        z.object({
            completedAt: z.number().optional(),
            createdAt: z.number(),
            id: z.string(),
            integrationId: z.string(),
            ownerId: z.string(),
            projects: z.array(z.string()).optional(),
            source: GetConfigurationsResponseBodySource$.outboundSchema.optional(),
            removedLogDrainsAt: z.number().optional(),
            removedProjectEnvsAt: z.number().optional(),
            removedTokensAt: z.number().optional(),
            removedWebhooksAt: z.number().optional(),
            slug: z.string(),
            teamId: z.nullable(z.string()).optional(),
            type: GetConfigurationsResponseBodyType$.outboundSchema,
            updatedAt: z.number(),
            userId: z.string(),
            scopes: z.array(z.string()),
            scopesQueue: z.array(z.lazy(() => ScopesQueue$.outboundSchema)).optional(),
            disabledAt: z.number().optional(),
            deletedAt: z.nullable(z.number()).optional(),
            disabledReason: GetConfigurationsResponseBodyDisabledReason$.outboundSchema.optional(),
            northstarMigratedAt: z.number().optional(),
            installationType: InstallationType$.outboundSchema.optional(),
        });
}

/** @internal */
export namespace GetConfigurationsResponseBody$ {
    export const inboundSchema: z.ZodType<GetConfigurationsResponseBody, z.ZodTypeDef, unknown> =
        z.union([
            z.lazy(() => GetConfigurationsResponseBody1$.inboundSchema),
            z.array(z.lazy(() => GetConfigurationsResponseBody2$.inboundSchema)),
        ]);

    export type Outbound =
        | GetConfigurationsResponseBody1$.Outbound
        | Array<GetConfigurationsResponseBody2$.Outbound>;
    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, GetConfigurationsResponseBody> =
        z.union([
            z.lazy(() => GetConfigurationsResponseBody1$.outboundSchema),
            z.array(z.lazy(() => GetConfigurationsResponseBody2$.outboundSchema)),
        ]);
}
