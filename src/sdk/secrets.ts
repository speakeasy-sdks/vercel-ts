/*
 * Code generated by Speakeasy (https://speakeasyapi.com). DO NOT EDIT.
 */

import { SDKHooks } from "../hooks/hooks.js";
import { SDKOptions, serverURLFromOptions } from "../lib/config.js";
import {
    encodeFormQuery as encodeFormQuery$,
    encodeJSON as encodeJSON$,
    encodeSimple as encodeSimple$,
} from "../lib/encodings.js";
import { HTTPClient } from "../lib/http.js";
import * as schemas$ from "../lib/schemas.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as models from "../models/index.js";

export class Secrets extends ClientSDK {
    private readonly options$: SDKOptions & { hooks?: SDKHooks };

    constructor(options: SDKOptions = {}) {
        const opt = options as unknown;
        let hooks: SDKHooks;
        if (
            typeof opt === "object" &&
            opt != null &&
            "hooks" in opt &&
            opt.hooks instanceof SDKHooks
        ) {
            hooks = opt.hooks;
        } else {
            hooks = new SDKHooks();
        }

        super({
            client: options.httpClient || new HTTPClient(),
            baseURL: serverURLFromOptions(options),
            hooks,
        });

        this.options$ = { ...options, hooks };
        void this.options$;
    }

    /**
     * List secrets
     *
     * @remarks
     * Retrieves the active Vercel secrets for the authenticated user or team. By default it returns 20 secrets. The rest can be retrieved using the pagination options. The body will contain an entry for each secret.
     */
    async list(
        id?: string | undefined,
        projectId?: string | undefined,
        teamId?: string | undefined,
        slug?: string | undefined,
        options?: RequestOptions
    ): Promise<models.GetSecretsResponseBody> {
        const input$: models.GetSecretsRequest = {
            id: id,
            projectId: projectId,
            teamId: teamId,
            slug: slug,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => models.GetSecretsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/v3/secrets")();

        const query$ = encodeFormQuery$({
            id: payload$.id,
            projectId: payload$.projectId,
            slug: payload$.slug,
            teamId: payload$.teamId,
        });

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "getSecrets",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["400", "401", "403", "410", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<models.GetSecretsResponseBody>()
            .json(200, models.GetSecretsResponseBody$inboundSchema)
            .fail([400, 401, 403, 410, "4XX", "5XX"])
            .match(response);

        return result$;
    }

    /**
     * Create a new secret
     *
     * @remarks
     * Allows to create a new secret.
     */
    async create(
        name: string,
        teamId?: string | undefined,
        slug?: string | undefined,
        requestBody?: models.CreateSecretRequestBody | undefined,
        options?: RequestOptions
    ): Promise<models.CreateSecretResponseBody> {
        const input$: models.CreateSecretRequest = {
            name: name,
            teamId: teamId,
            slug: slug,
            requestBody: requestBody,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => models.CreateSecretRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$.RequestBody, { explode: true });

        const pathParams$ = {
            name: encodeSimple$("name", payload$.name, { explode: false, charEncoding: "percent" }),
        };
        const path$ = this.templateURLComponent("/v2/secrets/{name}")(pathParams$);

        const query$ = encodeFormQuery$({
            slug: payload$.slug,
            teamId: payload$.teamId,
        });

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "createSecret",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["400", "401", "402", "403", "410", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<models.CreateSecretResponseBody>()
            .json(200, models.CreateSecretResponseBody$inboundSchema)
            .fail([400, 401, 402, 403, 410, "4XX", "5XX"])
            .match(response);

        return result$;
    }

    /**
     * Change secret name
     *
     * @remarks
     * Enables to edit the name of a secret. The name has to be unique to the user or team’s secrets.
     */
    async rename(
        name: string,
        teamId?: string | undefined,
        slug?: string | undefined,
        requestBody?: models.RenameSecretRequestBody | undefined,
        options?: RequestOptions
    ): Promise<models.RenameSecretResponseBody> {
        const input$: models.RenameSecretRequest = {
            name: name,
            teamId: teamId,
            slug: slug,
            requestBody: requestBody,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => models.RenameSecretRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$.RequestBody, { explode: true });

        const pathParams$ = {
            name: encodeSimple$("name", payload$.name, { explode: false, charEncoding: "percent" }),
        };
        const path$ = this.templateURLComponent("/v2/secrets/{name}")(pathParams$);

        const query$ = encodeFormQuery$({
            slug: payload$.slug,
            teamId: payload$.teamId,
        });

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "renameSecret",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PATCH",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["400", "401", "403", "410", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<models.RenameSecretResponseBody>()
            .json(200, models.RenameSecretResponseBody$inboundSchema)
            .fail([400, 401, 403, 410, "4XX", "5XX"])
            .match(response);

        return result$;
    }

    /**
     * Get a single secret
     *
     * @remarks
     * Retrieves the information for a specific secret by passing either the secret id or name in the URL.
     */
    async get(
        idOrName: string,
        decrypt?: models.QueryParamDecrypt | undefined,
        teamId?: string | undefined,
        slug?: string | undefined,
        options?: RequestOptions
    ): Promise<models.GetSecretResponseBody> {
        const input$: models.GetSecretRequest = {
            idOrName: idOrName,
            decrypt: decrypt,
            teamId: teamId,
            slug: slug,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => models.GetSecretRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            idOrName: encodeSimple$("idOrName", payload$.idOrName, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/v3/secrets/{idOrName}")(pathParams$);

        const query$ = encodeFormQuery$({
            decrypt: payload$.decrypt,
            slug: payload$.slug,
            teamId: payload$.teamId,
        });

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "getSecret",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["400", "401", "403", "404", "410", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<models.GetSecretResponseBody>()
            .json(200, models.GetSecretResponseBody$inboundSchema)
            .fail([400, 401, 403, 404, 410, "4XX", "5XX"])
            .match(response);

        return result$;
    }

    /**
     * Delete a secret
     *
     * @remarks
     * This deletes the user or team’s secret defined in the URL.
     */
    async delete(
        idOrName: string,
        teamId?: string | undefined,
        slug?: string | undefined,
        options?: RequestOptions
    ): Promise<models.DeleteSecretResponseBody> {
        const input$: models.DeleteSecretRequest = {
            idOrName: idOrName,
            teamId: teamId,
            slug: slug,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => models.DeleteSecretRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            idOrName: encodeSimple$("idOrName", payload$.idOrName, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/v2/secrets/{idOrName}#idOrName")(pathParams$);

        const query$ = encodeFormQuery$({
            slug: payload$.slug,
            teamId: payload$.teamId,
        });

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "deleteSecret",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["400", "401", "403", "410", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<models.DeleteSecretResponseBody>()
            .json(200, models.DeleteSecretResponseBody$inboundSchema)
            .fail([400, 401, 403, 410, "4XX", "5XX"])
            .match(response);

        return result$;
    }
}
