/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SDKHooks } from "../hooks/hooks.js";
import { SDKOptions, serverURLFromOptions } from "../lib/config.js";
import {
    encodeFormQuery as encodeFormQuery$,
    encodeJSON as encodeJSON$,
    encodeSimple as encodeSimple$,
} from "../lib/encodings.js";
import { HTTPClient } from "../lib/http.js";
import * as schemas$ from "../lib/schemas.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as models from "../models/index.js";
import * as z from "zod";

export enum GetDeploymentEventsAcceptEnum {
    applicationJson = "application/json",
    applicationStreamPlusJson = "application/stream+json",
}

export class Deployments extends ClientSDK {
    private readonly options$: SDKOptions & { hooks?: SDKHooks };

    constructor(options: SDKOptions = {}) {
        const opt = options as unknown;
        let hooks: SDKHooks;
        if (
            typeof opt === "object" &&
            opt != null &&
            "hooks" in opt &&
            opt.hooks instanceof SDKHooks
        ) {
            hooks = opt.hooks;
        } else {
            hooks = new SDKHooks();
        }

        super({
            client: options.httpClient || new HTTPClient(),
            baseURL: serverURLFromOptions(options),
            hooks,
        });

        this.options$ = { ...options, hooks };
        void this.options$;
    }

    /**
     * Get deployment events
     *
     * @remarks
     * Get the build logs of a deployment by deployment ID and build ID. It can work as an infinite stream of logs or as a JSON endpoint depending on the input parameters.
     */
    async getDeploymentEvents(
        request: models.GetDeploymentEventsRequest,
        options?: RequestOptions & { acceptHeaderOverride?: GetDeploymentEventsAcceptEnum }
    ): Promise<models.GetDeploymentEventsResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => models.GetDeploymentEventsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            idOrUrl: encodeSimple$("idOrUrl", payload$.idOrUrl, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/v2/deployments/{idOrUrl}/events")(pathParams$);

        const query$ = encodeFormQuery$({
            builds: payload$.builds,
            delimiter: payload$.delimiter,
            direction: payload$.direction,
            follow: payload$.follow,
            limit: payload$.limit,
            name: payload$.name,
            since: payload$.since,
            slug: payload$.slug,
            statusCode: payload$.statusCode,
            teamId: payload$.teamId,
            until: payload$.until,
        });

        const headers$ = new Headers({
            Accept:
                options?.acceptHeaderOverride ||
                "application/json;q=1, application/stream+json;q=0",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "getDeploymentEvents",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["400", "401", "403", "404", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<models.GetDeploymentEventsResponse>()
            .json(200, models.GetDeploymentEventsResponse$inboundSchema)
            .json(200, models.GetDeploymentEventsResponse$inboundSchema, {
                ctype: "application/stream+json",
            })
            .fail([400, 401, 403, 404, "4XX", "5XX"])
            .match(response);

        return result$;
    }

    /**
     * Get a deployment by ID or URL
     *
     * @remarks
     * Retrieves information for a deployment either by supplying its ID (`id` property) or Hostname (`url` property). Additional details will be included when the authenticated user or team is an owner of the deployment.
     */
    async getDeployment(
        idOrUrl: string,
        withGitRepoInfo?: string | undefined,
        teamId?: string | undefined,
        slug?: string | undefined,
        options?: RequestOptions
    ): Promise<models.GetDeploymentResponseBody> {
        const input$: models.GetDeploymentRequest = {
            idOrUrl: idOrUrl,
            withGitRepoInfo: withGitRepoInfo,
            teamId: teamId,
            slug: slug,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => models.GetDeploymentRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            idOrUrl: encodeSimple$("idOrUrl", payload$.idOrUrl, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/v13/deployments/{idOrUrl}")(pathParams$);

        const query$ = encodeFormQuery$({
            slug: payload$.slug,
            teamId: payload$.teamId,
            withGitRepoInfo: payload$.withGitRepoInfo,
        });

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "getDeployment",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "404", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<models.GetDeploymentResponseBody>()
            .json(200, models.GetDeploymentResponseBody$inboundSchema)
            .fail([400, 403, 404, "4XX", "5XX"])
            .match(response);

        return result$;
    }

    /**
     * Create a new deployment
     *
     * @remarks
     * Create a new deployment with all the required and intended data. If the deployment is not a git deployment, all files must be provided with the request, either referenced or inlined. Additionally, a deployment id can be specified to redeploy a previous deployment.
     */
    async create(
        request: models.CreateDeploymentRequest,
        options?: RequestOptions
    ): Promise<models.CreateDeploymentResponseBody> {
        const input$ = typeof request === "undefined" ? {} : request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => models.CreateDeploymentRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$.RequestBody, { explode: true });

        const path$ = this.templateURLComponent("/v13/deployments")();

        const query$ = encodeFormQuery$({
            forceNew: payload$.forceNew,
            skipAutoDetectionConfirmation: payload$.skipAutoDetectionConfirmation,
            slug: payload$.slug,
            teamId: payload$.teamId,
        });

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "createDeployment",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["400", "401", "402", "403", "404", "409", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<models.CreateDeploymentResponseBody>()
            .json(200, models.CreateDeploymentResponseBody$inboundSchema)
            .fail([400, 401, 402, 403, 404, 409, "4XX", "5XX"])
            .match(response);

        return result$;
    }

    /**
     * Cancel a deployment
     *
     * @remarks
     * This endpoint allows you to cancel a deployment which is currently building, by supplying its `id` in the URL.
     */
    async cancel(
        id: string,
        teamId?: string | undefined,
        slug?: string | undefined,
        options?: RequestOptions
    ): Promise<models.CancelDeploymentResponseBody> {
        const input$: models.CancelDeploymentRequest = {
            id: id,
            teamId: teamId,
            slug: slug,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => models.CancelDeploymentRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };
        const path$ = this.templateURLComponent("/v12/deployments/{id}/cancel")(pathParams$);

        const query$ = encodeFormQuery$({
            slug: payload$.slug,
            teamId: payload$.teamId,
        });

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "cancelDeployment",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PATCH",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["400", "401", "403", "404", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<models.CancelDeploymentResponseBody>()
            .json(200, models.CancelDeploymentResponseBody$inboundSchema)
            .fail([400, 401, 403, 404, "4XX", "5XX"])
            .match(response);

        return result$;
    }

    /**
     * Upload Deployment Files
     *
     * @remarks
     * Before you create a deployment you need to upload the required files for that deployment. To do it, you need to first upload each file to this endpoint. Once that's completed, you can create a new deployment with the uploaded files. The file content must be placed inside the body of the request. In the case of a successful response you'll receive a status code 200 with an empty body.
     */
    async uploadFile(
        request: models.UploadFileRequest,
        options?: RequestOptions
    ): Promise<models.UploadFileResponseBody> {
        const input$ = typeof request === "undefined" ? {} : request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => models.UploadFileRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/v2/files")();

        const query$ = encodeFormQuery$({
            slug: payload$.slug,
            teamId: payload$.teamId,
        });

        const headers$ = new Headers({
            Accept: "application/json",
            "Content-Length": encodeSimple$("Content-Length", payload$["Content-Length"], {
                explode: false,
                charEncoding: "none",
            }),
            "x-now-digest": encodeSimple$("x-now-digest", payload$["x-now-digest"], {
                explode: false,
                charEncoding: "none",
            }),
            "x-now-size": encodeSimple$("x-now-size", payload$["x-now-size"], {
                explode: false,
                charEncoding: "none",
            }),
            "x-vercel-digest": encodeSimple$("x-vercel-digest", payload$["x-vercel-digest"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "uploadFile",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["400", "401", "403", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<models.UploadFileResponseBody>()
            .json(200, models.UploadFileResponseBody$inboundSchema)
            .fail([400, 401, 403, "4XX", "5XX"])
            .match(response);

        return result$;
    }

    /**
     * List Deployment Files
     *
     * @remarks
     * Allows to retrieve the file structure of a deployment by supplying the deployment unique identifier.
     */
    async listDeploymentFiles(
        id: string,
        teamId?: string | undefined,
        slug?: string | undefined,
        options?: RequestOptions
    ): Promise<Array<models.FileTree>> {
        const input$: models.ListDeploymentFilesRequest = {
            id: id,
            teamId: teamId,
            slug: slug,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => models.ListDeploymentFilesRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };
        const path$ = this.templateURLComponent("/v6/deployments/{id}/files")(pathParams$);

        const query$ = encodeFormQuery$({
            slug: payload$.slug,
            teamId: payload$.teamId,
        });

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "listDeploymentFiles",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["400", "401", "403", "404", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<Array<models.FileTree>>()
            .json(200, z.array(models.FileTree$inboundSchema))
            .fail([400, 401, 403, 404, "4XX", "5XX"])
            .match(response);

        return result$;
    }

    /**
     * Get Deployment File Contents
     *
     * @remarks
     * Allows to retrieve the content of a file by supplying the file identifier and the deployment unique identifier. The response body will contain a JSON response containing the contents of the file encoded as base64.
     */
    async getDeploymentFileContents(
        request: models.GetDeploymentFileContentsRequest,
        options?: RequestOptions
    ): Promise<void> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => models.GetDeploymentFileContentsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            fileId: encodeSimple$("fileId", payload$.fileId, {
                explode: false,
                charEncoding: "percent",
            }),
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };
        const path$ = this.templateURLComponent("/v7/deployments/{id}/files/{fileId}")(pathParams$);

        const query$ = encodeFormQuery$({
            path: payload$.path,
            slug: payload$.slug,
            teamId: payload$.teamId,
        });

        const headers$ = new Headers({
            Accept: "*/*",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "getDeploymentFileContents",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["400", "401", "403", "404", "410", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<void>()
            .fail([400, 401, 403, 404, 410, "4XX", "5XX"])
            .void("2XX", z.void())
            .match(response);

        return result$;
    }

    /**
     * List deployments
     *
     * @remarks
     * List deployments under the authenticated user or team. If a deployment hasn't finished uploading (is incomplete), the `url` property will have a value of `null`.
     */
    async list(
        request: models.GetDeploymentsRequest,
        options?: RequestOptions
    ): Promise<models.GetDeploymentsResponseBody> {
        const input$ = typeof request === "undefined" ? {} : request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => models.GetDeploymentsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/v6/deployments")();

        const query$ = encodeFormQuery$({
            app: payload$.app,
            from: payload$.from,
            limit: payload$.limit,
            projectId: payload$.projectId,
            rollbackCandidate: payload$.rollbackCandidate,
            since: payload$.since,
            slug: payload$.slug,
            state: payload$.state,
            target: payload$.target,
            teamId: payload$.teamId,
            to: payload$.to,
            until: payload$.until,
            users: payload$.users,
        });

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "getDeployments",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["400", "401", "403", "404", "422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<models.GetDeploymentsResponseBody>()
            .json(200, models.GetDeploymentsResponseBody$inboundSchema)
            .fail([400, 401, 403, 404, 422, "4XX", "5XX"])
            .match(response);

        return result$;
    }

    /**
     * Delete a Deployment
     *
     * @remarks
     * This API allows you to delete a deployment, either by supplying its `id` in the URL or the `url` of the deployment as a query parameter. You can obtain the ID, for example, by listing all deployments.
     */
    async delete(
        id: string,
        url?: string | undefined,
        teamId?: string | undefined,
        slug?: string | undefined,
        options?: RequestOptions
    ): Promise<models.DeleteDeploymentResponseBody> {
        const input$: models.DeleteDeploymentRequest = {
            id: id,
            url: url,
            teamId: teamId,
            slug: slug,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => models.DeleteDeploymentRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };
        const path$ = this.templateURLComponent("/v13/deployments/{id}#id")(pathParams$);

        const query$ = encodeFormQuery$({
            slug: payload$.slug,
            teamId: payload$.teamId,
            url: payload$.url,
        });

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "deleteDeployment",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["400", "401", "403", "404", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<models.DeleteDeploymentResponseBody>()
            .json(200, models.DeleteDeploymentResponseBody$inboundSchema)
            .fail([400, 401, 403, 404, "4XX", "5XX"])
            .match(response);

        return result$;
    }
}
